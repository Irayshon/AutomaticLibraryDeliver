/* -*- C++ -*- */
/* Generated by /mnt/d/Work/OpenDDS-SDK-Build/OpenDDS-master/bin/opendds_idl version 3.23.0-dev (ACE version 6.2a_p25) running on input file Relay.idl */
#ifndef OPENDDS_IDL_GENERATED_RELAYTYPESUPPORTIMPL_H_CROR80
#define OPENDDS_IDL_GENERATED_RELAYTYPESUPPORTIMPL_H_CROR80

#include <dds/Version.h>
#if !OPENDDS_VERSION_EXACTLY(3, 23, 0)
#  error "This file should be regenerated with opendds_idl"
#endif
#include <dds/DCPS/Definitions.h>

#include <dds/DdsDcpsC.h>

#include "RelayC.h"
#include "RelayTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/ValueDispatcher.h"
#include "dds/DCPS/ValueReader.h"
#include "dds/DCPS/ValueWriter.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: RtpsRelay */



/* Begin CONST: HSPDP */


/* End CONST: HSPDP */


/* Begin CONST: HSEDP */


/* End CONST: HSEDP */


/* Begin CONST: HDATA */


/* End CONST: HDATA */


/* Begin CONST: VSPDP */


/* End CONST: VSPDP */


/* Begin CONST: VSEDP */


/* End CONST: VSEDP */


/* Begin CONST: VDATA */


/* End CONST: VDATA */


/* Begin TYPEDEF: GuidPrefix_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GuidPrefix_t_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GuidPrefix_t_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GuidPrefix_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GuidPrefix_9t_tag {};

template<> OpenDDS_RtpsRelayLib_Export
void set_default(IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag> arr);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::GuidPrefix_t, RtpsRelay_GuidPrefix_9t_tag>*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_EntityKey_t_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_EntityKey_t_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_EntityKey_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_EntityKey_9t_tag {};

template<> OpenDDS_RtpsRelayLib_Export
void set_default(IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag> arr);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::EntityKey_t, RtpsRelay_EntityKey_9t_tag>*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_EntityId_t_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_EntityId_t_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_EntityId_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::EntityId_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::EntityId_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::EntityId_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::EntityId_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::EntityId_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::EntityId_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::EntityId_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::EntityId_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::EntityId_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::EntityId_t>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::EntityId_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityId_t */


/* Begin STRUCT: GUID_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GUID_t_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GUID_t_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GUID_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::GUID_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::GUID_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::GUID_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::GUID_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::GUID_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::GUID_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::GUID_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::GUID_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::GUID_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::GUID_t>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::GUID_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GUID_t */


/* Begin TYPEDEF: StringSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_StringSequence_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_StringSequence_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_StringSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_StringSequence_tag {};

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag> seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::StringSequence, RtpsRelay_StringSequence_tag>*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSequence */


/* Begin TYPEDEF: GuidSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GuidSequence_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_GuidSequence_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_GuidSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GuidSequence_tag {};

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const IDL::DistinctType<const  ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag> seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_GuidSequence_nested_key_only_tag {};

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const IDL::DistinctType<const NestedKeyOnly<const  ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, IDL::DistinctType<NestedKeyOnly< ::RtpsRelay::GuidSequence>, RtpsRelay_GuidSequence_nested_key_only_tag> seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser, IDL::DistinctType< ::RtpsRelay::GuidSequence, RtpsRelay_GuidSequence_tag>*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidSequence */


/* Begin CONST: RELAY_PARTITIONS_TOPIC_NAME */


/* End CONST: RELAY_PARTITIONS_TOPIC_NAME */


/* Begin STRUCT: RelayPartitions */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayPartitions_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayPartitions_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayPartitions_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayPartitions& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayPartitions& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayPartitions& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayPartitions& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayPartitions& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayPartitions& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayPartitions>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayPartitions>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayPartitions>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::RelayPartitions>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::RelayPartitions>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayPartitions>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::RelayPartitions> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::RelayPartitions&) { return false; }
  static bool from_message_block( ::RtpsRelay::RelayPartitions&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export RelayPartitions_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::RelayPartitions& v1, const  ::RtpsRelay::RelayPartitions& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    if (v1.slot() < v2.slot()) return true;
    if (v2.slot() < v1.slot()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class RelayPartitionsTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::RelayPartitions> {
  typedef  ::RtpsRelay::RelayPartitions MessageType;
  typedef  ::RtpsRelay::RelayPartitionsSeq MessageSequenceType;
  typedef  ::RtpsRelay::RelayPartitionsTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::RelayPartitionsTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::RelayPartitionsDataWriter DataWriterType;
  typedef  ::RtpsRelay::RelayPartitionsDataReader DataReaderType;
  typedef  ::RtpsRelay::RelayPartitions_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::RelayPartitions> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_RelayPartitions_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::RelayPartitions"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 2; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export RelayPartitionsTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RelayPartitionsTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<RelayPartitions>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<RelayPartitions>
{
public:
  typedef RelayPartitionsTypeSupport TypeSupportType;
  typedef RelayPartitionsTypeSupport::_var_type _var_type;
  typedef RelayPartitionsTypeSupport::_ptr_type _ptr_type;

  RelayPartitionsTypeSupportImpl() {}
  virtual ~RelayPartitionsTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static RelayPartitionsTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayPartitions>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayPartitions*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayPartitions */


/* Begin CONST: RELAY_ADDRESSES_TOPIC_NAME */


/* End CONST: RELAY_ADDRESSES_TOPIC_NAME */


/* Begin STRUCT: RelayAddress */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayAddress_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayAddress_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayAddress_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayAddress& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayAddress& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayAddress& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayAddress& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayAddress& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayAddress& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayAddress>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayAddress>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayAddress>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::RelayAddress>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::RelayAddress>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayAddress>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::RelayAddress> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::RelayAddress&) { return false; }
  static bool from_message_block( ::RtpsRelay::RelayAddress&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export RelayAddress_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::RelayAddress& v1, const  ::RtpsRelay::RelayAddress& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    if (v1.name() < v2.name()) return true;
    if (v2.name() < v1.name()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class RelayAddressTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::RelayAddress> {
  typedef  ::RtpsRelay::RelayAddress MessageType;
  typedef  ::RtpsRelay::RelayAddressSeq MessageSequenceType;
  typedef  ::RtpsRelay::RelayAddressTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::RelayAddressTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::RelayAddressDataWriter DataWriterType;
  typedef  ::RtpsRelay::RelayAddressDataReader DataReaderType;
  typedef  ::RtpsRelay::RelayAddress_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::RelayAddress> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_RelayAddress_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::RelayAddress"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 2; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export RelayAddressTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RelayAddressTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<RelayAddress>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<RelayAddress>
{
public:
  typedef RelayAddressTypeSupport TypeSupportType;
  typedef RelayAddressTypeSupport::_var_type _var_type;
  typedef RelayAddressTypeSupport::_ptr_type _ptr_type;

  RelayAddressTypeSupportImpl() {}
  virtual ~RelayAddressTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static RelayAddressTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayAddress>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayAddress*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayAddress */


/* Begin CONST: RELAY_STATUS_TOPIC_NAME */


/* End CONST: RELAY_STATUS_TOPIC_NAME */


/* Begin STRUCT: RelayStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayStatus_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayStatus_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayStatus_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayStatus& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayStatus& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayStatus& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayStatus& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayStatus& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayStatus& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayStatus>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::RelayStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::RelayStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayStatus>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::RelayStatus> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::RelayStatus&) { return false; }
  static bool from_message_block( ::RtpsRelay::RelayStatus&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export RelayStatus_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::RelayStatus& v1, const  ::RtpsRelay::RelayStatus& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class RelayStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::RelayStatus> {
  typedef  ::RtpsRelay::RelayStatus MessageType;
  typedef  ::RtpsRelay::RelayStatusSeq MessageSequenceType;
  typedef  ::RtpsRelay::RelayStatusTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::RelayStatusTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::RelayStatusDataWriter DataWriterType;
  typedef  ::RtpsRelay::RelayStatusDataReader DataReaderType;
  typedef  ::RtpsRelay::RelayStatus_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::RelayStatus> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_RelayStatus_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::RelayStatus"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 1; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export RelayStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RelayStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<RelayStatus>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<RelayStatus>
{
public:
  typedef RelayStatusTypeSupport TypeSupportType;
  typedef RelayStatusTypeSupport::_var_type _var_type;
  typedef RelayStatusTypeSupport::_ptr_type _ptr_type;

  RelayStatusTypeSupportImpl() {}
  virtual ~RelayStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static RelayStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayStatus>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayStatus*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayStatus */


/* Begin CONST: RELAY_PARTICIPANT_STATUS_TOPIC_NAME */


/* End CONST: RELAY_PARTICIPANT_STATUS_TOPIC_NAME */


/* Begin STRUCT: RelayParticipantStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayParticipantStatus_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayParticipantStatus_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayParticipantStatus_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayParticipantStatus& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayParticipantStatus& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayParticipantStatus& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayParticipantStatus& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayParticipantStatus& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayParticipantStatus& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayParticipantStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayParticipantStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayParticipantStatus>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::RelayParticipantStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::RelayParticipantStatus>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayParticipantStatus>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::RelayParticipantStatus> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::RelayParticipantStatus&) { return false; }
  static bool from_message_block( ::RtpsRelay::RelayParticipantStatus&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return MUTABLE; }
  static Extensibility max_extensibility_level() { return MUTABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export RelayParticipantStatus_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::RelayParticipantStatus& v1, const  ::RtpsRelay::RelayParticipantStatus& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    if (v1.guid().guidPrefix()[0] < v2.guid().guidPrefix()[0]) return true;
    if (v2.guid().guidPrefix()[0] < v1.guid().guidPrefix()[0]) return false;
    if (v1.guid().guidPrefix()[1] < v2.guid().guidPrefix()[1]) return true;
    if (v2.guid().guidPrefix()[1] < v1.guid().guidPrefix()[1]) return false;
    if (v1.guid().guidPrefix()[2] < v2.guid().guidPrefix()[2]) return true;
    if (v2.guid().guidPrefix()[2] < v1.guid().guidPrefix()[2]) return false;
    if (v1.guid().guidPrefix()[3] < v2.guid().guidPrefix()[3]) return true;
    if (v2.guid().guidPrefix()[3] < v1.guid().guidPrefix()[3]) return false;
    if (v1.guid().guidPrefix()[4] < v2.guid().guidPrefix()[4]) return true;
    if (v2.guid().guidPrefix()[4] < v1.guid().guidPrefix()[4]) return false;
    if (v1.guid().guidPrefix()[5] < v2.guid().guidPrefix()[5]) return true;
    if (v2.guid().guidPrefix()[5] < v1.guid().guidPrefix()[5]) return false;
    if (v1.guid().guidPrefix()[6] < v2.guid().guidPrefix()[6]) return true;
    if (v2.guid().guidPrefix()[6] < v1.guid().guidPrefix()[6]) return false;
    if (v1.guid().guidPrefix()[7] < v2.guid().guidPrefix()[7]) return true;
    if (v2.guid().guidPrefix()[7] < v1.guid().guidPrefix()[7]) return false;
    if (v1.guid().guidPrefix()[8] < v2.guid().guidPrefix()[8]) return true;
    if (v2.guid().guidPrefix()[8] < v1.guid().guidPrefix()[8]) return false;
    if (v1.guid().guidPrefix()[9] < v2.guid().guidPrefix()[9]) return true;
    if (v2.guid().guidPrefix()[9] < v1.guid().guidPrefix()[9]) return false;
    if (v1.guid().guidPrefix()[10] < v2.guid().guidPrefix()[10]) return true;
    if (v2.guid().guidPrefix()[10] < v1.guid().guidPrefix()[10]) return false;
    if (v1.guid().guidPrefix()[11] < v2.guid().guidPrefix()[11]) return true;
    if (v2.guid().guidPrefix()[11] < v1.guid().guidPrefix()[11]) return false;
    if (v1.guid().entityId().entityKey()[0] < v2.guid().entityId().entityKey()[0]) return true;
    if (v2.guid().entityId().entityKey()[0] < v1.guid().entityId().entityKey()[0]) return false;
    if (v1.guid().entityId().entityKey()[1] < v2.guid().entityId().entityKey()[1]) return true;
    if (v2.guid().entityId().entityKey()[1] < v1.guid().entityId().entityKey()[1]) return false;
    if (v1.guid().entityId().entityKey()[2] < v2.guid().entityId().entityKey()[2]) return true;
    if (v2.guid().entityId().entityKey()[2] < v1.guid().entityId().entityKey()[2]) return false;
    if (v1.guid().entityId().entityKind() < v2.guid().entityId().entityKind()) return true;
    if (v2.guid().entityId().entityKind() < v1.guid().entityId().entityKind()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class RelayParticipantStatusTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::RelayParticipantStatus> {
  typedef  ::RtpsRelay::RelayParticipantStatus MessageType;
  typedef  ::RtpsRelay::RelayParticipantStatusSeq MessageSequenceType;
  typedef  ::RtpsRelay::RelayParticipantStatusTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::RelayParticipantStatusTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::RelayParticipantStatusDataWriter DataWriterType;
  typedef  ::RtpsRelay::RelayParticipantStatusDataReader DataReaderType;
  typedef  ::RtpsRelay::RelayParticipantStatus_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::RelayParticipantStatus> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_RelayParticipantStatus_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::RelayParticipantStatus"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 17; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export RelayParticipantStatusTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RelayParticipantStatusTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<RelayParticipantStatus>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<RelayParticipantStatus>
{
public:
  typedef RelayParticipantStatusTypeSupport TypeSupportType;
  typedef RelayParticipantStatusTypeSupport::_var_type _var_type;
  typedef RelayParticipantStatusTypeSupport::_ptr_type _ptr_type;

  RelayParticipantStatusTypeSupportImpl() {}
  virtual ~RelayParticipantStatusTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static RelayParticipantStatusTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayParticipantStatus>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayParticipantStatus*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayParticipantStatus */


/* Begin CONST: SPDP_REPLAY_TOPIC_NAME */


/* End CONST: SPDP_REPLAY_TOPIC_NAME */


/* Begin STRUCT: SpdpReplay */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_SpdpReplay_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_SpdpReplay_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_SpdpReplay_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::SpdpReplay& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::SpdpReplay& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::SpdpReplay& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::SpdpReplay& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::SpdpReplay& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::SpdpReplay& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::SpdpReplay>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::SpdpReplay>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::SpdpReplay>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::SpdpReplay>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::SpdpReplay>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::SpdpReplay>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::SpdpReplay> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::SpdpReplay&) { return false; }
  static bool from_message_block( ::RtpsRelay::SpdpReplay&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export SpdpReplay_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::SpdpReplay&, const  ::RtpsRelay::SpdpReplay&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}


namespace RtpsRelay {
class SpdpReplayTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::SpdpReplay> {
  typedef  ::RtpsRelay::SpdpReplay MessageType;
  typedef  ::RtpsRelay::SpdpReplaySeq MessageSequenceType;
  typedef  ::RtpsRelay::SpdpReplayTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::SpdpReplayTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::SpdpReplayDataWriter DataWriterType;
  typedef  ::RtpsRelay::SpdpReplayDataReader DataReaderType;
  typedef  ::RtpsRelay::SpdpReplay_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::SpdpReplay> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_SpdpReplay_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::SpdpReplay"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export SpdpReplayTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SpdpReplayTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<SpdpReplay>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<SpdpReplay>
{
public:
  typedef SpdpReplayTypeSupport TypeSupportType;
  typedef SpdpReplayTypeSupport::_var_type _var_type;
  typedef SpdpReplayTypeSupport::_ptr_type _ptr_type;

  SpdpReplayTypeSupportImpl() {}
  virtual ~SpdpReplayTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static SpdpReplayTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::SpdpReplay>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::SpdpReplay*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SpdpReplay */


/* Begin STRUCT: RelayHeader */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayHeader_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayHeader_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayHeader_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayHeader& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayHeader& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayHeader& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayHeader& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayHeader& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayHeader& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayHeader>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayHeader>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayHeader>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayHeader>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayHeader*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayHeader */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_Duration_t_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_Duration_t_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_Duration_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::Duration_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::Duration_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::Duration_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::Duration_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::Duration_t& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::Duration_t& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::Duration_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::Duration_t>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::Duration_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::Duration_t>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::Duration_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin STRUCT: ProtocolStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_ProtocolStatistics_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_ProtocolStatistics_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_ProtocolStatistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::ProtocolStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::ProtocolStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::ProtocolStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::ProtocolStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::ProtocolStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::ProtocolStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::ProtocolStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::ProtocolStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::ProtocolStatistics>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::ProtocolStatistics>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::ProtocolStatistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ProtocolStatistics */


/* Begin CONST: PARTICIPANT_STATISTICS_TOPIC_NAME */


/* End CONST: PARTICIPANT_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: ParticipantStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_ParticipantStatistics_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_ParticipantStatistics_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_ParticipantStatistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::ParticipantStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::ParticipantStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::ParticipantStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::ParticipantStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::ParticipantStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::ParticipantStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::ParticipantStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::ParticipantStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::ParticipantStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::ParticipantStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::ParticipantStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::ParticipantStatistics>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::ParticipantStatistics> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::ParticipantStatistics&) { return false; }
  static bool from_message_block( ::RtpsRelay::ParticipantStatistics&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return MUTABLE; }
  static Extensibility max_extensibility_level() { return MUTABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export ParticipantStatistics_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::ParticipantStatistics& v1, const  ::RtpsRelay::ParticipantStatistics& v2) const
  {
    if (v1.guid().guidPrefix()[0] < v2.guid().guidPrefix()[0]) return true;
    if (v2.guid().guidPrefix()[0] < v1.guid().guidPrefix()[0]) return false;
    if (v1.guid().guidPrefix()[1] < v2.guid().guidPrefix()[1]) return true;
    if (v2.guid().guidPrefix()[1] < v1.guid().guidPrefix()[1]) return false;
    if (v1.guid().guidPrefix()[2] < v2.guid().guidPrefix()[2]) return true;
    if (v2.guid().guidPrefix()[2] < v1.guid().guidPrefix()[2]) return false;
    if (v1.guid().guidPrefix()[3] < v2.guid().guidPrefix()[3]) return true;
    if (v2.guid().guidPrefix()[3] < v1.guid().guidPrefix()[3]) return false;
    if (v1.guid().guidPrefix()[4] < v2.guid().guidPrefix()[4]) return true;
    if (v2.guid().guidPrefix()[4] < v1.guid().guidPrefix()[4]) return false;
    if (v1.guid().guidPrefix()[5] < v2.guid().guidPrefix()[5]) return true;
    if (v2.guid().guidPrefix()[5] < v1.guid().guidPrefix()[5]) return false;
    if (v1.guid().guidPrefix()[6] < v2.guid().guidPrefix()[6]) return true;
    if (v2.guid().guidPrefix()[6] < v1.guid().guidPrefix()[6]) return false;
    if (v1.guid().guidPrefix()[7] < v2.guid().guidPrefix()[7]) return true;
    if (v2.guid().guidPrefix()[7] < v1.guid().guidPrefix()[7]) return false;
    if (v1.guid().guidPrefix()[8] < v2.guid().guidPrefix()[8]) return true;
    if (v2.guid().guidPrefix()[8] < v1.guid().guidPrefix()[8]) return false;
    if (v1.guid().guidPrefix()[9] < v2.guid().guidPrefix()[9]) return true;
    if (v2.guid().guidPrefix()[9] < v1.guid().guidPrefix()[9]) return false;
    if (v1.guid().guidPrefix()[10] < v2.guid().guidPrefix()[10]) return true;
    if (v2.guid().guidPrefix()[10] < v1.guid().guidPrefix()[10]) return false;
    if (v1.guid().guidPrefix()[11] < v2.guid().guidPrefix()[11]) return true;
    if (v2.guid().guidPrefix()[11] < v1.guid().guidPrefix()[11]) return false;
    if (v1.guid().entityId().entityKey()[0] < v2.guid().entityId().entityKey()[0]) return true;
    if (v2.guid().entityId().entityKey()[0] < v1.guid().entityId().entityKey()[0]) return false;
    if (v1.guid().entityId().entityKey()[1] < v2.guid().entityId().entityKey()[1]) return true;
    if (v2.guid().entityId().entityKey()[1] < v1.guid().entityId().entityKey()[1]) return false;
    if (v1.guid().entityId().entityKey()[2] < v2.guid().entityId().entityKey()[2]) return true;
    if (v2.guid().entityId().entityKey()[2] < v1.guid().entityId().entityKey()[2]) return false;
    if (v1.guid().entityId().entityKind() < v2.guid().entityId().entityKind()) return true;
    if (v2.guid().entityId().entityKind() < v1.guid().entityId().entityKind()) return false;
    if (v1.name() < v2.name()) return true;
    if (v2.name() < v1.name()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class ParticipantStatisticsTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::ParticipantStatistics> {
  typedef  ::RtpsRelay::ParticipantStatistics MessageType;
  typedef  ::RtpsRelay::ParticipantStatisticsSeq MessageSequenceType;
  typedef  ::RtpsRelay::ParticipantStatisticsTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::ParticipantStatisticsTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::ParticipantStatisticsDataWriter DataWriterType;
  typedef  ::RtpsRelay::ParticipantStatisticsDataReader DataReaderType;
  typedef  ::RtpsRelay::ParticipantStatistics_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::ParticipantStatistics> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_ParticipantStatistics_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::ParticipantStatistics"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 17; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export ParticipantStatisticsTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantStatisticsTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<ParticipantStatistics>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<ParticipantStatistics>
{
public:
  typedef ParticipantStatisticsTypeSupport TypeSupportType;
  typedef ParticipantStatisticsTypeSupport::_var_type _var_type;
  typedef ParticipantStatisticsTypeSupport::_ptr_type _ptr_type;

  ParticipantStatisticsTypeSupportImpl() {}
  virtual ~ParticipantStatisticsTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static ParticipantStatisticsTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::ParticipantStatistics>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::ParticipantStatistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantStatistics */


/* Begin CONST: HANDLER_STATISTICS_TOPIC_NAME */


/* End CONST: HANDLER_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: HandlerStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_HandlerStatistics_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_HandlerStatistics_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_HandlerStatistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::HandlerStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::HandlerStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::HandlerStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::HandlerStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::HandlerStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::HandlerStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::HandlerStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::HandlerStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::HandlerStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::HandlerStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::HandlerStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::HandlerStatistics>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::HandlerStatistics> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::HandlerStatistics&) { return false; }
  static bool from_message_block( ::RtpsRelay::HandlerStatistics&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return MUTABLE; }
  static Extensibility max_extensibility_level() { return MUTABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export HandlerStatistics_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::HandlerStatistics& v1, const  ::RtpsRelay::HandlerStatistics& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    if (v1.name() < v2.name()) return true;
    if (v2.name() < v1.name()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class HandlerStatisticsTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::HandlerStatistics> {
  typedef  ::RtpsRelay::HandlerStatistics MessageType;
  typedef  ::RtpsRelay::HandlerStatisticsSeq MessageSequenceType;
  typedef  ::RtpsRelay::HandlerStatisticsTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::HandlerStatisticsTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::HandlerStatisticsDataWriter DataWriterType;
  typedef  ::RtpsRelay::HandlerStatisticsDataReader DataReaderType;
  typedef  ::RtpsRelay::HandlerStatistics_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::HandlerStatistics> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_HandlerStatistics_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::HandlerStatistics"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 2; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export HandlerStatisticsTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<HandlerStatisticsTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<HandlerStatistics>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<HandlerStatistics>
{
public:
  typedef HandlerStatisticsTypeSupport TypeSupportType;
  typedef HandlerStatisticsTypeSupport::_var_type _var_type;
  typedef HandlerStatisticsTypeSupport::_ptr_type _ptr_type;

  HandlerStatisticsTypeSupportImpl() {}
  virtual ~HandlerStatisticsTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static HandlerStatisticsTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::HandlerStatistics>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::HandlerStatistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HandlerStatistics */


/* Begin CONST: RELAY_STATISTICS_TOPIC_NAME */


/* End CONST: RELAY_STATISTICS_TOPIC_NAME */


/* Begin STRUCT: RelayStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct RtpsRelay_RelayStatistics_xtag {};
template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<RtpsRelay_RelayStatistics_xtag>();

template<> OpenDDS_RtpsRelayLib_Export
const XTypes::TypeMap& getMinimalTypeMap<RtpsRelay_RelayStatistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::RtpsRelay::RelayStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_RtpsRelayLib_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::RtpsRelay::RelayStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_RtpsRelayLib_Export
void set_default( ::RtpsRelay::RelayStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::RtpsRelay::RelayStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const ::RtpsRelay::RelayStatistics& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm,  ::RtpsRelay::RelayStatistics& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::RtpsRelay::RelayStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::RtpsRelay::RelayStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::RtpsRelay::RelayStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::RtpsRelay::RelayStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::RtpsRelay::RelayStatistics>& stru);

OpenDDS_RtpsRelayLib_Export
bool operator>>(Serializer& strm, const KeyOnly< ::RtpsRelay::RelayStatistics>& stru);

template <>
struct MarshalTraits< ::RtpsRelay::RelayStatistics> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::RtpsRelay::RelayStatistics&) { return false; }
  static bool from_message_block( ::RtpsRelay::RelayStatistics&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return MUTABLE; }
  static Extensibility max_extensibility_level() { return MUTABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_RtpsRelayLib_Export RelayStatistics_OpenDDS_KeyLessThan {
  bool operator()(const  ::RtpsRelay::RelayStatistics& v1, const  ::RtpsRelay::RelayStatistics& v2) const
  {
    if (v1.relay_id() < v2.relay_id()) return true;
    if (v2.relay_id() < v1.relay_id()) return false;
    return false;
  }
};
}


namespace RtpsRelay {
class RelayStatisticsTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::RtpsRelay::RelayStatistics> {
  typedef  ::RtpsRelay::RelayStatistics MessageType;
  typedef  ::RtpsRelay::RelayStatisticsSeq MessageSequenceType;
  typedef  ::RtpsRelay::RelayStatisticsTypeSupport TypeSupportType;
  typedef  ::RtpsRelay::RelayStatisticsTypeSupportImpl TypeSupportImplType;
  typedef  ::RtpsRelay::RelayStatisticsDataWriter DataWriterType;
  typedef  ::RtpsRelay::RelayStatisticsDataReader DataReaderType;
  typedef  ::RtpsRelay::RelayStatistics_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::RtpsRelay::RelayStatistics> KeyOnlyType;
  typedef OpenDDS::DCPS::RtpsRelay_RelayStatistics_xtag XtagType;

  static const char* type_name() { return "RtpsRelay::RelayStatistics"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 1; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace RtpsRelay {
class OpenDDS_RtpsRelayLib_Export RelayStatisticsTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<RelayStatisticsTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<RelayStatistics>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<RelayStatistics>
{
public:
  typedef RelayStatisticsTypeSupport TypeSupportType;
  typedef RelayStatisticsTypeSupport::_var_type _var_type;
  typedef RelayStatisticsTypeSupport::_ptr_type _ptr_type;

  RelayStatisticsTypeSupportImpl() {}
  virtual ~RelayStatisticsTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static RelayStatisticsTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_RtpsRelayLib_Export
const MetaStruct& getMetaStruct< ::RtpsRelay::RelayStatistics>();
OpenDDS_RtpsRelayLib_Export
bool gen_skip_over(Serializer& ser,  ::RtpsRelay::RelayStatistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: RelayStatistics */

/* End MODULE: RtpsRelay */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_RELAYTYPESUPPORTIMPL_H_CROR80 */
