/* -*- C++ -*- */
/* Generated by /mnt/d/Work/OpenDDS-SDK-Build/OpenDDS-master/bin/opendds_idl version 3.23.0-dev (ACE version 6.2a_p25) running on input file OpenddsDcpsExt.idl */
#ifndef OPENDDS_IDL_GENERATED_OPENDDSDCPSEXTTYPESUPPORTIMPL_H_CD8DBP
#define OPENDDS_IDL_GENERATED_OPENDDSDCPSEXTTYPESUPPORTIMPL_H_CD8DBP

#include <dds/Version.h>
#if !OPENDDS_VERSION_EXACTLY(3, 23, 0)
#  error "This file should be regenerated with opendds_idl"
#endif
#include <dds/DCPS/Definitions.h>

#include <dds/DdsDcpsC.h>

#include "OpenddsDcpsExtC.h"
#include "OpenddsDcpsExtTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/ValueDispatcher.h"
#include "dds/DCPS/ValueReader.h"
#include "dds/DCPS/ValueWriter.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DdsDcpsCoreC.h"
#include "dds/DdsDcpsGuidC.h"
#include "dds/DCPS/dcps_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: ParticipantLocation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ParticipantLocation_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ParticipantLocation_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ParticipantLocation_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ParticipantLocation */


/* Begin CONST: LOCATION_LOCAL */


/* End CONST: LOCATION_LOCAL */


/* Begin CONST: LOCATION_ICE */


/* End CONST: LOCATION_ICE */


/* Begin CONST: LOCATION_RELAY */


/* End CONST: LOCATION_RELAY */


/* Begin CONST: LOCATION_LOCAL6 */


/* End CONST: LOCATION_LOCAL6 */


/* Begin CONST: LOCATION_ICE6 */


/* End CONST: LOCATION_ICE6 */


/* Begin CONST: LOCATION_RELAY6 */


/* End CONST: LOCATION_RELAY6 */


/* Begin STRUCT: ParticipantLocationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export ParticipantLocationBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& v1, const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.guid[0] < v2.guid[0]) return true;
    if (v2.guid[0] < v1.guid[0]) return false;
    if (v1.guid[1] < v2.guid[1]) return true;
    if (v2.guid[1] < v1.guid[1]) return false;
    if (v1.guid[2] < v2.guid[2]) return true;
    if (v2.guid[2] < v1.guid[2]) return false;
    if (v1.guid[3] < v2.guid[3]) return true;
    if (v2.guid[3] < v1.guid[3]) return false;
    if (v1.guid[4] < v2.guid[4]) return true;
    if (v2.guid[4] < v1.guid[4]) return false;
    if (v1.guid[5] < v2.guid[5]) return true;
    if (v2.guid[5] < v1.guid[5]) return false;
    if (v1.guid[6] < v2.guid[6]) return true;
    if (v2.guid[6] < v1.guid[6]) return false;
    if (v1.guid[7] < v2.guid[7]) return true;
    if (v2.guid[7] < v1.guid[7]) return false;
    if (v1.guid[8] < v2.guid[8]) return true;
    if (v2.guid[8] < v1.guid[8]) return false;
    if (v1.guid[9] < v2.guid[9]) return true;
    if (v2.guid[9] < v1.guid[9]) return false;
    if (v1.guid[10] < v2.guid[10]) return true;
    if (v2.guid[10] < v1.guid[10]) return false;
    if (v1.guid[11] < v2.guid[11]) return true;
    if (v2.guid[11] < v1.guid[11]) return false;
    if (v1.guid[12] < v2.guid[12]) return true;
    if (v2.guid[12] < v1.guid[12]) return false;
    if (v1.guid[13] < v2.guid[13]) return true;
    if (v2.guid[13] < v1.guid[13]) return false;
    if (v1.guid[14] < v2.guid[14]) return true;
    if (v2.guid[14] < v1.guid[14]) return false;
    if (v1.guid[15] < v2.guid[15]) return true;
    if (v2.guid[15] < v1.guid[15]) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class ParticipantLocationBuiltinTopicDataTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData> {
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData MessageType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicDataDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_ParticipantLocationBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::ParticipantLocationBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_Dcps_Export ParticipantLocationBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantLocationBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<ParticipantLocationBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<ParticipantLocationBuiltinTopicData>
{
public:
  typedef ParticipantLocationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef ParticipantLocationBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef ParticipantLocationBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  ParticipantLocationBuiltinTopicDataTypeSupportImpl() {}
  virtual ~ParticipantLocationBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static ParticipantLocationBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ParticipantLocationBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantLocationBuiltinTopicData */


/* Begin CONST: RTPS_RELAY_STUN_PROTOCOL */


/* End CONST: RTPS_RELAY_STUN_PROTOCOL */


/* Begin STRUCT: ConnectionRecord */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ConnectionRecord_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ConnectionRecord_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ConnectionRecord_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ConnectionRecord& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ConnectionRecord& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::ConnectionRecord& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::ConnectionRecord& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::ConnectionRecord& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ConnectionRecord& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::ConnectionRecord>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::ConnectionRecord>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ConnectionRecord>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::ConnectionRecord>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::ConnectionRecord>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ConnectionRecord>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::ConnectionRecord> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::ConnectionRecord&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::ConnectionRecord&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export ConnectionRecord_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::ConnectionRecord& v1, const  ::OpenDDS::DCPS::ConnectionRecord& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.guid[0] < v2.guid[0]) return true;
    if (v2.guid[0] < v1.guid[0]) return false;
    if (v1.guid[1] < v2.guid[1]) return true;
    if (v2.guid[1] < v1.guid[1]) return false;
    if (v1.guid[2] < v2.guid[2]) return true;
    if (v2.guid[2] < v1.guid[2]) return false;
    if (v1.guid[3] < v2.guid[3]) return true;
    if (v2.guid[3] < v1.guid[3]) return false;
    if (v1.guid[4] < v2.guid[4]) return true;
    if (v2.guid[4] < v1.guid[4]) return false;
    if (v1.guid[5] < v2.guid[5]) return true;
    if (v2.guid[5] < v1.guid[5]) return false;
    if (v1.guid[6] < v2.guid[6]) return true;
    if (v2.guid[6] < v1.guid[6]) return false;
    if (v1.guid[7] < v2.guid[7]) return true;
    if (v2.guid[7] < v1.guid[7]) return false;
    if (v1.guid[8] < v2.guid[8]) return true;
    if (v2.guid[8] < v1.guid[8]) return false;
    if (v1.guid[9] < v2.guid[9]) return true;
    if (v2.guid[9] < v1.guid[9]) return false;
    if (v1.guid[10] < v2.guid[10]) return true;
    if (v2.guid[10] < v1.guid[10]) return false;
    if (v1.guid[11] < v2.guid[11]) return true;
    if (v2.guid[11] < v1.guid[11]) return false;
    if (v1.guid[12] < v2.guid[12]) return true;
    if (v2.guid[12] < v1.guid[12]) return false;
    if (v1.guid[13] < v2.guid[13]) return true;
    if (v2.guid[13] < v1.guid[13]) return false;
    if (v1.guid[14] < v2.guid[14]) return true;
    if (v2.guid[14] < v1.guid[14]) return false;
    if (v1.guid[15] < v2.guid[15]) return true;
    if (v2.guid[15] < v1.guid[15]) return false;
    if (v1.address < v2.address) return true;
    if (v2.address < v1.address) return false;
    if (v1.protocol < v2.protocol) return true;
    if (v2.protocol < v1.protocol) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class ConnectionRecordTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::ConnectionRecord> {
  typedef  ::OpenDDS::DCPS::ConnectionRecord MessageType;
  typedef  ::OpenDDS::DCPS::ConnectionRecordSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::ConnectionRecordTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::ConnectionRecordTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::ConnectionRecordDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::ConnectionRecordDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::ConnectionRecord_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::ConnectionRecord> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_ConnectionRecord_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::ConnectionRecord"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 18; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_Dcps_Export ConnectionRecordTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ConnectionRecordTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<ConnectionRecord>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<ConnectionRecord>
{
public:
  typedef ConnectionRecordTypeSupport TypeSupportType;
  typedef ConnectionRecordTypeSupport::_var_type _var_type;
  typedef ConnectionRecordTypeSupport::_ptr_type _ptr_type;

  ConnectionRecordTypeSupportImpl() {}
  virtual ~ConnectionRecordTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static ConnectionRecordTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ConnectionRecord>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ConnectionRecord*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ConnectionRecord */


/* Begin STRUCT: InternalThreadBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::InternalThreadBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export InternalThreadBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& v1, const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.thread_id < v2.thread_id) return true;
    if (v2.thread_id < v1.thread_id) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class InternalThreadBuiltinTopicDataTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData> {
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData MessageType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicDataDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_InternalThreadBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::InternalThreadBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 1; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_Dcps_Export InternalThreadBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<InternalThreadBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<InternalThreadBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<InternalThreadBuiltinTopicData>
{
public:
  typedef InternalThreadBuiltinTopicDataTypeSupport TypeSupportType;
  typedef InternalThreadBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef InternalThreadBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  InternalThreadBuiltinTopicDataTypeSupportImpl() {}
  virtual ~InternalThreadBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static InternalThreadBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::InternalThreadBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::InternalThreadBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InternalThreadBuiltinTopicData */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: Locator_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_Locator_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_Locator_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_Locator_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::Locator_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::Locator_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::Locator_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::Locator_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::Locator_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::Locator_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::Locator_t>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::Locator_t>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::Locator_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::Locator_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::Locator_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_LocatorSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_LocatorSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_LocatorSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::LocatorSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::LocatorSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::LocatorSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::LocatorSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: MessageCountKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_MessageCountKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCountKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCountKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MessageCountKind */


/* Begin CONST: MCK_RTPS */


/* End CONST: MCK_RTPS */


/* Begin CONST: MCK_STUN */


/* End CONST: MCK_STUN */


/* Begin STRUCT: MessageCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_MessageCount_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCount_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCount_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::MessageCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::MessageCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::MessageCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::MessageCount& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::MessageCount& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::MessageCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::MessageCount>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::MessageCount>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::MessageCount>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::MessageCount>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::MessageCount*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: MessageCount */


/* Begin STRUCT: GuidCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_GuidCount_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidCount_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidCount_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::GuidCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::GuidCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::GuidCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::GuidCount& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::GuidCount& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::GuidCount>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::GuidCount>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::GuidCount>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::GuidCount>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidCount*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GuidCount */


/* Begin TYPEDEF: MessageCountSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_MessageCountSequence_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_MessageCountSequence_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_MessageCountSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::MessageCountSequence& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::MessageCountSequence& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::MessageCountSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCountSequence>& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::MessageCountSequence>& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::MessageCountSequence>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::MessageCountSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: MessageCountSequence */


/* Begin TYPEDEF: GuidCountSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_GuidCountSequence_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GuidCountSequence_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GuidCountSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GuidCountSequence& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GuidCountSequence& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GuidCountSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCountSequence>& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::GuidCountSequence>& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::GuidCountSequence>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GuidCountSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: GuidCountSequence */


/* Begin STRUCT: TransportStatistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_TransportStatistics_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportStatistics_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportStatistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TransportStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TransportStatistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::OpenDDS::DCPS::TransportStatistics& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::TransportStatistics& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::TransportStatistics& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportStatistics& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::TransportStatistics>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::TransportStatistics>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TransportStatistics>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TransportStatistics>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportStatistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportStatistics */


/* Begin TYPEDEF: TransportStatisticsSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_TransportStatisticsSequence_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportStatisticsSequence_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportStatisticsSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::TransportStatisticsSequence& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::TransportStatisticsSequence& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportStatisticsSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatisticsSequence>& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::TransportStatisticsSequence>& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::TransportStatisticsSequence>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportStatisticsSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: TransportStatisticsSequence */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_OPENDDSDCPSEXTTYPESUPPORTIMPL_H_CD8DBP */
