/* -*- C++ -*- */
/* Generated by /mnt/d/Work/OpenDDS-SDK-Build/OpenDDS-master/bin/opendds_idl version 3.23.0-dev (ACE version 6.2a_p25) running on input file monitor.idl */
#ifndef OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_US2NMR
#define OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_US2NMR

#include <dds/Version.h>
#if !OPENDDS_VERSION_EXACTLY(3, 23, 0)
#  error "This file should be regenerated with opendds_idl"
#endif
#include <dds/DCPS/Definitions.h>

#include <dds/DdsDcpsC.h>

#include "monitorC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/ValueDispatcher.h"
#include "dds/DCPS/ValueReader.h"
#include "dds/DCPS/ValueWriter.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "dds/DdsDcpsGuidC.h"
#include "dds/DdsDcpsInfrastructureC.h"
#include "monitorTypeSupportC.h"
#include "tao/ULongSeqC.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */


/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */


/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */


/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin CONST: DOMAIN_UNKNOWN */


/* End CONST: DOMAIN_UNKNOWN */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ULongSeq */


/* End TYPEDEF: ULongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: MONITOR_DOMAIN_ID */


/* End CONST: MONITOR_DOMAIN_ID */


/* Begin CONST: MONITOR_TRANSPORT_ID */


/* End CONST: MONITOR_TRANSPORT_ID */


/* Begin CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: SERVICE_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* End CONST: DOMAIN_PARTICIPANT_MONITOR_TOPIC */


/* Begin CONST: TOPIC_MONITOR_TOPIC */


/* End CONST: TOPIC_MONITOR_TOPIC */


/* Begin CONST: PUBLISHER_MONITOR_TOPIC */


/* End CONST: PUBLISHER_MONITOR_TOPIC */


/* Begin CONST: SUBSCRIBER_MONITOR_TOPIC */


/* End CONST: SUBSCRIBER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_MONITOR_TOPIC */


/* Begin CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_WRITER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_MONITOR_TOPIC */


/* End CONST: DATA_READER_MONITOR_TOPIC */


/* Begin CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* End CONST: DATA_READER_PERIODIC_MONITOR_TOPIC */


/* Begin CONST: TRANSPORT_MONITOR_TOPIC */


/* End CONST: TRANSPORT_MONITOR_TOPIC */


/* Begin STRUCT: Statistics */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_Statistics_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_Statistics_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_Statistics_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::Statistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::Statistics& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::Statistics& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::Statistics>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::Statistics>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::Statistics>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::Statistics>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::Statistics*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Statistics */


/* Begin ENUM: ValueEnumType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ValueEnumType_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ValueEnumType_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ValueEnumType_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ValueEnumType& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ValueEnumType& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ValueEnumType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ValueEnumType& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export extern const char* gen_OpenDDS_DCPS_ValueEnumType_names[];
OpenDDS_monitor_Export extern const size_t gen_OpenDDS_DCPS_ValueEnumType_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ValueEnumType */


/* Begin UNION: ValueUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ValueUnion_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ValueUnion_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ValueUnion_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ValueUnion& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ValueUnion& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ValueUnion& uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, NestedKeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::ValueUnion> uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const  ::OpenDDS::DCPS::ValueUnion> uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly< ::OpenDDS::DCPS::ValueUnion> uni);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::ValueUnion> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::ValueUnion&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::ValueUnion&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ValueUnion>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ValueUnion*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: ValueUnion */


/* Begin STRUCT: NameValuePair */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_NameValuePair_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_NameValuePair_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_NameValuePair_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::NameValuePair& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::NameValuePair& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::NameValuePair& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::NameValuePair>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::NameValuePair>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::NameValuePair>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::NameValuePair>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::NameValuePair*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NameValuePair */


/* Begin TYPEDEF: NVPSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_NVPSeq_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_NVPSeq_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_NVPSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::NVPSeq& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::NVPSeq& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::NVPSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::NVPSeq>& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::NVPSeq>& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::NVPSeq>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::NVPSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: NVPSeq */


/* Begin STRUCT: ServiceParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ServiceParticipantReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ServiceParticipantReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ServiceParticipantReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ServiceParticipantReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ServiceParticipantReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ServiceParticipantReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::ServiceParticipantReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::ServiceParticipantReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::ServiceParticipantReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::ServiceParticipantReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export ServiceParticipantReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::ServiceParticipantReport& v1, const  ::OpenDDS::DCPS::ServiceParticipantReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class ServiceParticipantReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::ServiceParticipantReport> {
  typedef  ::OpenDDS::DCPS::ServiceParticipantReport MessageType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::ServiceParticipantReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::ServiceParticipantReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_ServiceParticipantReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::ServiceParticipantReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 2; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export ServiceParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ServiceParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<ServiceParticipantReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<ServiceParticipantReport>
{
public:
  typedef ServiceParticipantReportTypeSupport TypeSupportType;
  typedef ServiceParticipantReportTypeSupport::_var_type _var_type;
  typedef ServiceParticipantReportTypeSupport::_ptr_type _ptr_type;

  ServiceParticipantReportTypeSupportImpl() {}
  virtual ~ServiceParticipantReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static ServiceParticipantReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::ServiceParticipantReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::ServiceParticipantReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ServiceParticipantReport */


/* Begin STRUCT: DomainParticipantReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DomainParticipantReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DomainParticipantReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DomainParticipantReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DomainParticipantReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DomainParticipantReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DomainParticipantReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::DomainParticipantReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DomainParticipantReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::DomainParticipantReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::DomainParticipantReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::DomainParticipantReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export DomainParticipantReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::DomainParticipantReport& v1, const  ::OpenDDS::DCPS::DomainParticipantReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dp_id.guidPrefix[0] < v2.dp_id.guidPrefix[0]) return true;
    if (v2.dp_id.guidPrefix[0] < v1.dp_id.guidPrefix[0]) return false;
    if (v1.dp_id.guidPrefix[1] < v2.dp_id.guidPrefix[1]) return true;
    if (v2.dp_id.guidPrefix[1] < v1.dp_id.guidPrefix[1]) return false;
    if (v1.dp_id.guidPrefix[2] < v2.dp_id.guidPrefix[2]) return true;
    if (v2.dp_id.guidPrefix[2] < v1.dp_id.guidPrefix[2]) return false;
    if (v1.dp_id.guidPrefix[3] < v2.dp_id.guidPrefix[3]) return true;
    if (v2.dp_id.guidPrefix[3] < v1.dp_id.guidPrefix[3]) return false;
    if (v1.dp_id.guidPrefix[4] < v2.dp_id.guidPrefix[4]) return true;
    if (v2.dp_id.guidPrefix[4] < v1.dp_id.guidPrefix[4]) return false;
    if (v1.dp_id.guidPrefix[5] < v2.dp_id.guidPrefix[5]) return true;
    if (v2.dp_id.guidPrefix[5] < v1.dp_id.guidPrefix[5]) return false;
    if (v1.dp_id.guidPrefix[6] < v2.dp_id.guidPrefix[6]) return true;
    if (v2.dp_id.guidPrefix[6] < v1.dp_id.guidPrefix[6]) return false;
    if (v1.dp_id.guidPrefix[7] < v2.dp_id.guidPrefix[7]) return true;
    if (v2.dp_id.guidPrefix[7] < v1.dp_id.guidPrefix[7]) return false;
    if (v1.dp_id.guidPrefix[8] < v2.dp_id.guidPrefix[8]) return true;
    if (v2.dp_id.guidPrefix[8] < v1.dp_id.guidPrefix[8]) return false;
    if (v1.dp_id.guidPrefix[9] < v2.dp_id.guidPrefix[9]) return true;
    if (v2.dp_id.guidPrefix[9] < v1.dp_id.guidPrefix[9]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DomainParticipantReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::DomainParticipantReport> {
  typedef  ::OpenDDS::DCPS::DomainParticipantReport MessageType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::DomainParticipantReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::DomainParticipantReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_DomainParticipantReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::DomainParticipantReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DomainParticipantReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DomainParticipantReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<DomainParticipantReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<DomainParticipantReport>
{
public:
  typedef DomainParticipantReportTypeSupport TypeSupportType;
  typedef DomainParticipantReportTypeSupport::_var_type _var_type;
  typedef DomainParticipantReportTypeSupport::_ptr_type _ptr_type;

  DomainParticipantReportTypeSupportImpl() {}
  virtual ~DomainParticipantReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static DomainParticipantReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DomainParticipantReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DomainParticipantReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantReport */


/* Begin STRUCT: TopicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_TopicReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TopicReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TopicReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TopicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TopicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TopicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::TopicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::TopicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TopicReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::TopicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::TopicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::TopicReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::TopicReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::TopicReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::TopicReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export TopicReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::TopicReport& v1, const  ::OpenDDS::DCPS::TopicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.topic_id.guidPrefix[0] < v2.topic_id.guidPrefix[0]) return true;
    if (v2.topic_id.guidPrefix[0] < v1.topic_id.guidPrefix[0]) return false;
    if (v1.topic_id.guidPrefix[1] < v2.topic_id.guidPrefix[1]) return true;
    if (v2.topic_id.guidPrefix[1] < v1.topic_id.guidPrefix[1]) return false;
    if (v1.topic_id.guidPrefix[2] < v2.topic_id.guidPrefix[2]) return true;
    if (v2.topic_id.guidPrefix[2] < v1.topic_id.guidPrefix[2]) return false;
    if (v1.topic_id.guidPrefix[3] < v2.topic_id.guidPrefix[3]) return true;
    if (v2.topic_id.guidPrefix[3] < v1.topic_id.guidPrefix[3]) return false;
    if (v1.topic_id.guidPrefix[4] < v2.topic_id.guidPrefix[4]) return true;
    if (v2.topic_id.guidPrefix[4] < v1.topic_id.guidPrefix[4]) return false;
    if (v1.topic_id.guidPrefix[5] < v2.topic_id.guidPrefix[5]) return true;
    if (v2.topic_id.guidPrefix[5] < v1.topic_id.guidPrefix[5]) return false;
    if (v1.topic_id.guidPrefix[6] < v2.topic_id.guidPrefix[6]) return true;
    if (v2.topic_id.guidPrefix[6] < v1.topic_id.guidPrefix[6]) return false;
    if (v1.topic_id.guidPrefix[7] < v2.topic_id.guidPrefix[7]) return true;
    if (v2.topic_id.guidPrefix[7] < v1.topic_id.guidPrefix[7]) return false;
    if (v1.topic_id.guidPrefix[8] < v2.topic_id.guidPrefix[8]) return true;
    if (v2.topic_id.guidPrefix[8] < v1.topic_id.guidPrefix[8]) return false;
    if (v1.topic_id.guidPrefix[9] < v2.topic_id.guidPrefix[9]) return true;
    if (v2.topic_id.guidPrefix[9] < v1.topic_id.guidPrefix[9]) return false;
    if (v1.topic_id.guidPrefix[10] < v2.topic_id.guidPrefix[10]) return true;
    if (v2.topic_id.guidPrefix[10] < v1.topic_id.guidPrefix[10]) return false;
    if (v1.topic_id.guidPrefix[11] < v2.topic_id.guidPrefix[11]) return true;
    if (v2.topic_id.guidPrefix[11] < v1.topic_id.guidPrefix[11]) return false;
    if (v1.topic_id.entityId.entityKey[0] < v2.topic_id.entityId.entityKey[0]) return true;
    if (v2.topic_id.entityId.entityKey[0] < v1.topic_id.entityId.entityKey[0]) return false;
    if (v1.topic_id.entityId.entityKey[1] < v2.topic_id.entityId.entityKey[1]) return true;
    if (v2.topic_id.entityId.entityKey[1] < v1.topic_id.entityId.entityKey[1]) return false;
    if (v1.topic_id.entityId.entityKey[2] < v2.topic_id.entityId.entityKey[2]) return true;
    if (v2.topic_id.entityId.entityKey[2] < v1.topic_id.entityId.entityKey[2]) return false;
    if (v1.topic_id.entityId.entityKind < v2.topic_id.entityId.entityKind) return true;
    if (v2.topic_id.entityId.entityKind < v1.topic_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class TopicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::TopicReport> {
  typedef  ::OpenDDS::DCPS::TopicReport MessageType;
  typedef  ::OpenDDS::DCPS::TopicReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::TopicReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::TopicReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::TopicReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::TopicReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::TopicReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::TopicReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_TopicReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::TopicReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export TopicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<TopicReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<TopicReport>
{
public:
  typedef TopicReportTypeSupport TypeSupportType;
  typedef TopicReportTypeSupport::_var_type _var_type;
  typedef TopicReportTypeSupport::_ptr_type _ptr_type;

  TopicReportTypeSupportImpl() {}
  virtual ~TopicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static TopicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TopicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TopicReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicReport */


/* Begin STRUCT: PublisherReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_PublisherReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_PublisherReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_PublisherReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::PublisherReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::PublisherReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::PublisherReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::PublisherReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::PublisherReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::PublisherReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::PublisherReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::PublisherReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::PublisherReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::PublisherReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(20);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::PublisherReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::PublisherReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export PublisherReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::PublisherReport& v1, const  ::OpenDDS::DCPS::PublisherReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[0] < v2.dp_id.guidPrefix[0]) return true;
    if (v2.dp_id.guidPrefix[0] < v1.dp_id.guidPrefix[0]) return false;
    if (v1.dp_id.guidPrefix[1] < v2.dp_id.guidPrefix[1]) return true;
    if (v2.dp_id.guidPrefix[1] < v1.dp_id.guidPrefix[1]) return false;
    if (v1.dp_id.guidPrefix[2] < v2.dp_id.guidPrefix[2]) return true;
    if (v2.dp_id.guidPrefix[2] < v1.dp_id.guidPrefix[2]) return false;
    if (v1.dp_id.guidPrefix[3] < v2.dp_id.guidPrefix[3]) return true;
    if (v2.dp_id.guidPrefix[3] < v1.dp_id.guidPrefix[3]) return false;
    if (v1.dp_id.guidPrefix[4] < v2.dp_id.guidPrefix[4]) return true;
    if (v2.dp_id.guidPrefix[4] < v1.dp_id.guidPrefix[4]) return false;
    if (v1.dp_id.guidPrefix[5] < v2.dp_id.guidPrefix[5]) return true;
    if (v2.dp_id.guidPrefix[5] < v1.dp_id.guidPrefix[5]) return false;
    if (v1.dp_id.guidPrefix[6] < v2.dp_id.guidPrefix[6]) return true;
    if (v2.dp_id.guidPrefix[6] < v1.dp_id.guidPrefix[6]) return false;
    if (v1.dp_id.guidPrefix[7] < v2.dp_id.guidPrefix[7]) return true;
    if (v2.dp_id.guidPrefix[7] < v1.dp_id.guidPrefix[7]) return false;
    if (v1.dp_id.guidPrefix[8] < v2.dp_id.guidPrefix[8]) return true;
    if (v2.dp_id.guidPrefix[8] < v1.dp_id.guidPrefix[8]) return false;
    if (v1.dp_id.guidPrefix[9] < v2.dp_id.guidPrefix[9]) return true;
    if (v2.dp_id.guidPrefix[9] < v1.dp_id.guidPrefix[9]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class PublisherReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::PublisherReport> {
  typedef  ::OpenDDS::DCPS::PublisherReport MessageType;
  typedef  ::OpenDDS::DCPS::PublisherReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::PublisherReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::PublisherReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::PublisherReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::PublisherReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::PublisherReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::PublisherReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_PublisherReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::PublisherReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 17; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export PublisherReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublisherReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<PublisherReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<PublisherReport>
{
public:
  typedef PublisherReportTypeSupport TypeSupportType;
  typedef PublisherReportTypeSupport::_var_type _var_type;
  typedef PublisherReportTypeSupport::_ptr_type _ptr_type;

  PublisherReportTypeSupportImpl() {}
  virtual ~PublisherReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static PublisherReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::PublisherReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::PublisherReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherReport */


/* Begin STRUCT: SubscriberReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_SubscriberReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_SubscriberReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_SubscriberReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::SubscriberReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::SubscriberReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::SubscriberReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::SubscriberReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::SubscriberReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::SubscriberReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::SubscriberReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::SubscriberReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::SubscriberReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::SubscriberReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(20);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::SubscriberReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::SubscriberReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export SubscriberReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::SubscriberReport& v1, const  ::OpenDDS::DCPS::SubscriberReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.handle < v2.handle) return true;
    if (v2.handle < v1.handle) return false;
    if (v1.dp_id.guidPrefix[0] < v2.dp_id.guidPrefix[0]) return true;
    if (v2.dp_id.guidPrefix[0] < v1.dp_id.guidPrefix[0]) return false;
    if (v1.dp_id.guidPrefix[1] < v2.dp_id.guidPrefix[1]) return true;
    if (v2.dp_id.guidPrefix[1] < v1.dp_id.guidPrefix[1]) return false;
    if (v1.dp_id.guidPrefix[2] < v2.dp_id.guidPrefix[2]) return true;
    if (v2.dp_id.guidPrefix[2] < v1.dp_id.guidPrefix[2]) return false;
    if (v1.dp_id.guidPrefix[3] < v2.dp_id.guidPrefix[3]) return true;
    if (v2.dp_id.guidPrefix[3] < v1.dp_id.guidPrefix[3]) return false;
    if (v1.dp_id.guidPrefix[4] < v2.dp_id.guidPrefix[4]) return true;
    if (v2.dp_id.guidPrefix[4] < v1.dp_id.guidPrefix[4]) return false;
    if (v1.dp_id.guidPrefix[5] < v2.dp_id.guidPrefix[5]) return true;
    if (v2.dp_id.guidPrefix[5] < v1.dp_id.guidPrefix[5]) return false;
    if (v1.dp_id.guidPrefix[6] < v2.dp_id.guidPrefix[6]) return true;
    if (v2.dp_id.guidPrefix[6] < v1.dp_id.guidPrefix[6]) return false;
    if (v1.dp_id.guidPrefix[7] < v2.dp_id.guidPrefix[7]) return true;
    if (v2.dp_id.guidPrefix[7] < v1.dp_id.guidPrefix[7]) return false;
    if (v1.dp_id.guidPrefix[8] < v2.dp_id.guidPrefix[8]) return true;
    if (v2.dp_id.guidPrefix[8] < v1.dp_id.guidPrefix[8]) return false;
    if (v1.dp_id.guidPrefix[9] < v2.dp_id.guidPrefix[9]) return true;
    if (v2.dp_id.guidPrefix[9] < v1.dp_id.guidPrefix[9]) return false;
    if (v1.dp_id.guidPrefix[10] < v2.dp_id.guidPrefix[10]) return true;
    if (v2.dp_id.guidPrefix[10] < v1.dp_id.guidPrefix[10]) return false;
    if (v1.dp_id.guidPrefix[11] < v2.dp_id.guidPrefix[11]) return true;
    if (v2.dp_id.guidPrefix[11] < v1.dp_id.guidPrefix[11]) return false;
    if (v1.dp_id.entityId.entityKey[0] < v2.dp_id.entityId.entityKey[0]) return true;
    if (v2.dp_id.entityId.entityKey[0] < v1.dp_id.entityId.entityKey[0]) return false;
    if (v1.dp_id.entityId.entityKey[1] < v2.dp_id.entityId.entityKey[1]) return true;
    if (v2.dp_id.entityId.entityKey[1] < v1.dp_id.entityId.entityKey[1]) return false;
    if (v1.dp_id.entityId.entityKey[2] < v2.dp_id.entityId.entityKey[2]) return true;
    if (v2.dp_id.entityId.entityKey[2] < v1.dp_id.entityId.entityKey[2]) return false;
    if (v1.dp_id.entityId.entityKind < v2.dp_id.entityId.entityKind) return true;
    if (v2.dp_id.entityId.entityKind < v1.dp_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class SubscriberReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::SubscriberReport> {
  typedef  ::OpenDDS::DCPS::SubscriberReport MessageType;
  typedef  ::OpenDDS::DCPS::SubscriberReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::SubscriberReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::SubscriberReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::SubscriberReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::SubscriberReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::SubscriberReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::SubscriberReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_SubscriberReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::SubscriberReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 17; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export SubscriberReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriberReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<SubscriberReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<SubscriberReport>
{
public:
  typedef SubscriberReportTypeSupport TypeSupportType;
  typedef SubscriberReportTypeSupport::_var_type _var_type;
  typedef SubscriberReportTypeSupport::_ptr_type _ptr_type;

  SubscriberReportTypeSupportImpl() {}
  virtual ~SubscriberReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static SubscriberReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::SubscriberReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::SubscriberReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberReport */


/* Begin STRUCT: DataWriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataWriterAssociation_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterAssociation_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterAssociation_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterAssociation& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterAssociation& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterAssociation& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterAssociation>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterAssociation>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociation>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterAssociation>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterAssociation*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociation */


/* Begin TYPEDEF: DWAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DWAssociations_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DWAssociations_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DWAssociations_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DWAssociations& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DWAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DWAssociations& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociations>& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociations>& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DWAssociations>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DWAssociations*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociations */


/* Begin STRUCT: DataWriterReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataWriterReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::DataWriterReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::DataWriterReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataWriterReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::DataWriterReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::DataWriterReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::DataWriterReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export DataWriterReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::DataWriterReport& v1, const  ::OpenDDS::DCPS::DataWriterReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dw_id.guidPrefix[0] < v2.dw_id.guidPrefix[0]) return true;
    if (v2.dw_id.guidPrefix[0] < v1.dw_id.guidPrefix[0]) return false;
    if (v1.dw_id.guidPrefix[1] < v2.dw_id.guidPrefix[1]) return true;
    if (v2.dw_id.guidPrefix[1] < v1.dw_id.guidPrefix[1]) return false;
    if (v1.dw_id.guidPrefix[2] < v2.dw_id.guidPrefix[2]) return true;
    if (v2.dw_id.guidPrefix[2] < v1.dw_id.guidPrefix[2]) return false;
    if (v1.dw_id.guidPrefix[3] < v2.dw_id.guidPrefix[3]) return true;
    if (v2.dw_id.guidPrefix[3] < v1.dw_id.guidPrefix[3]) return false;
    if (v1.dw_id.guidPrefix[4] < v2.dw_id.guidPrefix[4]) return true;
    if (v2.dw_id.guidPrefix[4] < v1.dw_id.guidPrefix[4]) return false;
    if (v1.dw_id.guidPrefix[5] < v2.dw_id.guidPrefix[5]) return true;
    if (v2.dw_id.guidPrefix[5] < v1.dw_id.guidPrefix[5]) return false;
    if (v1.dw_id.guidPrefix[6] < v2.dw_id.guidPrefix[6]) return true;
    if (v2.dw_id.guidPrefix[6] < v1.dw_id.guidPrefix[6]) return false;
    if (v1.dw_id.guidPrefix[7] < v2.dw_id.guidPrefix[7]) return true;
    if (v2.dw_id.guidPrefix[7] < v1.dw_id.guidPrefix[7]) return false;
    if (v1.dw_id.guidPrefix[8] < v2.dw_id.guidPrefix[8]) return true;
    if (v2.dw_id.guidPrefix[8] < v1.dw_id.guidPrefix[8]) return false;
    if (v1.dw_id.guidPrefix[9] < v2.dw_id.guidPrefix[9]) return true;
    if (v2.dw_id.guidPrefix[9] < v1.dw_id.guidPrefix[9]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataWriterReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::DataWriterReport> {
  typedef  ::OpenDDS::DCPS::DataWriterReport MessageType;
  typedef  ::OpenDDS::DCPS::DataWriterReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::DataWriterReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::DataWriterReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::DataWriterReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::DataWriterReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::DataWriterReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::DataWriterReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_DataWriterReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::DataWriterReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataWriterReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<DataWriterReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<DataWriterReport>
{
public:
  typedef DataWriterReportTypeSupport TypeSupportType;
  typedef DataWriterReportTypeSupport::_var_type _var_type;
  typedef DataWriterReportTypeSupport::_ptr_type _ptr_type;

  DataWriterReportTypeSupportImpl() {}
  virtual ~DataWriterReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static DataWriterReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterReport */


/* Begin STRUCT: DataWriterAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataWriterAssociationPeriodic_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterAssociationPeriodic_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterAssociationPeriodic_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterAssociationPeriodic>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterAssociationPeriodic>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterAssociationPeriodic*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterAssociationPeriodic */


/* Begin TYPEDEF: DWAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DWAssociationsPeriodic_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DWAssociationsPeriodic_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DWAssociationsPeriodic_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DWAssociationsPeriodic& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DWAssociationsPeriodic>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DWAssociationsPeriodic*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DWAssociationsPeriodic */


/* Begin STRUCT: DataWriterPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataWriterPeriodicReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataWriterPeriodicReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataWriterPeriodicReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataWriterPeriodicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataWriterPeriodicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataWriterPeriodicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataWriterPeriodicReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::DataWriterPeriodicReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::DataWriterPeriodicReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::DataWriterPeriodicReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export DataWriterPeriodicReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::DataWriterPeriodicReport& v1, const  ::OpenDDS::DCPS::DataWriterPeriodicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dw_id.guidPrefix[0] < v2.dw_id.guidPrefix[0]) return true;
    if (v2.dw_id.guidPrefix[0] < v1.dw_id.guidPrefix[0]) return false;
    if (v1.dw_id.guidPrefix[1] < v2.dw_id.guidPrefix[1]) return true;
    if (v2.dw_id.guidPrefix[1] < v1.dw_id.guidPrefix[1]) return false;
    if (v1.dw_id.guidPrefix[2] < v2.dw_id.guidPrefix[2]) return true;
    if (v2.dw_id.guidPrefix[2] < v1.dw_id.guidPrefix[2]) return false;
    if (v1.dw_id.guidPrefix[3] < v2.dw_id.guidPrefix[3]) return true;
    if (v2.dw_id.guidPrefix[3] < v1.dw_id.guidPrefix[3]) return false;
    if (v1.dw_id.guidPrefix[4] < v2.dw_id.guidPrefix[4]) return true;
    if (v2.dw_id.guidPrefix[4] < v1.dw_id.guidPrefix[4]) return false;
    if (v1.dw_id.guidPrefix[5] < v2.dw_id.guidPrefix[5]) return true;
    if (v2.dw_id.guidPrefix[5] < v1.dw_id.guidPrefix[5]) return false;
    if (v1.dw_id.guidPrefix[6] < v2.dw_id.guidPrefix[6]) return true;
    if (v2.dw_id.guidPrefix[6] < v1.dw_id.guidPrefix[6]) return false;
    if (v1.dw_id.guidPrefix[7] < v2.dw_id.guidPrefix[7]) return true;
    if (v2.dw_id.guidPrefix[7] < v1.dw_id.guidPrefix[7]) return false;
    if (v1.dw_id.guidPrefix[8] < v2.dw_id.guidPrefix[8]) return true;
    if (v2.dw_id.guidPrefix[8] < v1.dw_id.guidPrefix[8]) return false;
    if (v1.dw_id.guidPrefix[9] < v2.dw_id.guidPrefix[9]) return true;
    if (v2.dw_id.guidPrefix[9] < v1.dw_id.guidPrefix[9]) return false;
    if (v1.dw_id.guidPrefix[10] < v2.dw_id.guidPrefix[10]) return true;
    if (v2.dw_id.guidPrefix[10] < v1.dw_id.guidPrefix[10]) return false;
    if (v1.dw_id.guidPrefix[11] < v2.dw_id.guidPrefix[11]) return true;
    if (v2.dw_id.guidPrefix[11] < v1.dw_id.guidPrefix[11]) return false;
    if (v1.dw_id.entityId.entityKey[0] < v2.dw_id.entityId.entityKey[0]) return true;
    if (v2.dw_id.entityId.entityKey[0] < v1.dw_id.entityId.entityKey[0]) return false;
    if (v1.dw_id.entityId.entityKey[1] < v2.dw_id.entityId.entityKey[1]) return true;
    if (v2.dw_id.entityId.entityKey[1] < v1.dw_id.entityId.entityKey[1]) return false;
    if (v1.dw_id.entityId.entityKey[2] < v2.dw_id.entityId.entityKey[2]) return true;
    if (v2.dw_id.entityId.entityKey[2] < v1.dw_id.entityId.entityKey[2]) return false;
    if (v1.dw_id.entityId.entityKind < v2.dw_id.entityId.entityKind) return true;
    if (v2.dw_id.entityId.entityKind < v1.dw_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataWriterPeriodicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::DataWriterPeriodicReport> {
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReport MessageType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::DataWriterPeriodicReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::DataWriterPeriodicReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_DataWriterPeriodicReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::DataWriterPeriodicReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataWriterPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataWriterPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<DataWriterPeriodicReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<DataWriterPeriodicReport>
{
public:
  typedef DataWriterPeriodicReportTypeSupport TypeSupportType;
  typedef DataWriterPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataWriterPeriodicReportTypeSupport::_ptr_type _ptr_type;

  DataWriterPeriodicReportTypeSupportImpl() {}
  virtual ~DataWriterPeriodicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static DataWriterPeriodicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataWriterPeriodicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataWriterPeriodicReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterPeriodicReport */


/* Begin STRUCT: DataReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataReaderAssociation_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderAssociation_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderAssociation_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderAssociation& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderAssociation& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderAssociation& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderAssociation>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderAssociation>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociation>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderAssociation>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderAssociation*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociation */


/* Begin TYPEDEF: DRAssociations */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DRAssociations_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DRAssociations_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DRAssociations_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DRAssociations& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DRAssociations& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DRAssociations& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociations>& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociations>& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DRAssociations>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DRAssociations*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociations */


/* Begin STRUCT: DataReaderReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataReaderReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::DataReaderReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::DataReaderReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataReaderReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::DataReaderReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::DataReaderReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::DataReaderReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export DataReaderReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::DataReaderReport& v1, const  ::OpenDDS::DCPS::DataReaderReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dr_id.guidPrefix[0] < v2.dr_id.guidPrefix[0]) return true;
    if (v2.dr_id.guidPrefix[0] < v1.dr_id.guidPrefix[0]) return false;
    if (v1.dr_id.guidPrefix[1] < v2.dr_id.guidPrefix[1]) return true;
    if (v2.dr_id.guidPrefix[1] < v1.dr_id.guidPrefix[1]) return false;
    if (v1.dr_id.guidPrefix[2] < v2.dr_id.guidPrefix[2]) return true;
    if (v2.dr_id.guidPrefix[2] < v1.dr_id.guidPrefix[2]) return false;
    if (v1.dr_id.guidPrefix[3] < v2.dr_id.guidPrefix[3]) return true;
    if (v2.dr_id.guidPrefix[3] < v1.dr_id.guidPrefix[3]) return false;
    if (v1.dr_id.guidPrefix[4] < v2.dr_id.guidPrefix[4]) return true;
    if (v2.dr_id.guidPrefix[4] < v1.dr_id.guidPrefix[4]) return false;
    if (v1.dr_id.guidPrefix[5] < v2.dr_id.guidPrefix[5]) return true;
    if (v2.dr_id.guidPrefix[5] < v1.dr_id.guidPrefix[5]) return false;
    if (v1.dr_id.guidPrefix[6] < v2.dr_id.guidPrefix[6]) return true;
    if (v2.dr_id.guidPrefix[6] < v1.dr_id.guidPrefix[6]) return false;
    if (v1.dr_id.guidPrefix[7] < v2.dr_id.guidPrefix[7]) return true;
    if (v2.dr_id.guidPrefix[7] < v1.dr_id.guidPrefix[7]) return false;
    if (v1.dr_id.guidPrefix[8] < v2.dr_id.guidPrefix[8]) return true;
    if (v2.dr_id.guidPrefix[8] < v1.dr_id.guidPrefix[8]) return false;
    if (v1.dr_id.guidPrefix[9] < v2.dr_id.guidPrefix[9]) return true;
    if (v2.dr_id.guidPrefix[9] < v1.dr_id.guidPrefix[9]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataReaderReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::DataReaderReport> {
  typedef  ::OpenDDS::DCPS::DataReaderReport MessageType;
  typedef  ::OpenDDS::DCPS::DataReaderReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::DataReaderReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::DataReaderReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::DataReaderReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::DataReaderReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::DataReaderReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::DataReaderReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_DataReaderReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::DataReaderReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataReaderReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<DataReaderReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<DataReaderReport>
{
public:
  typedef DataReaderReportTypeSupport TypeSupportType;
  typedef DataReaderReportTypeSupport::_var_type _var_type;
  typedef DataReaderReportTypeSupport::_ptr_type _ptr_type;

  DataReaderReportTypeSupportImpl() {}
  virtual ~DataReaderReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static DataReaderReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderReport */


/* Begin STRUCT: DataReaderAssociationPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataReaderAssociationPeriodic_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderAssociationPeriodic_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderAssociationPeriodic_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderAssociationPeriodic>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderAssociationPeriodic>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderAssociationPeriodic*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderAssociationPeriodic */


/* Begin TYPEDEF: DRAssociationsPeriodic */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DRAssociationsPeriodic_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DRAssociationsPeriodic_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DRAssociationsPeriodic_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DRAssociationsPeriodic& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const  ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::DRAssociationsPeriodic>& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DRAssociationsPeriodic*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DRAssociationsPeriodic */


/* Begin STRUCT: DataReaderPeriodicReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_DataReaderPeriodicReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_DataReaderPeriodicReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_DataReaderPeriodicReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::DataReaderPeriodicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::DataReaderPeriodicReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::DataReaderPeriodicReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::DataReaderPeriodicReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::DataReaderPeriodicReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::DataReaderPeriodicReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::DataReaderPeriodicReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export DataReaderPeriodicReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::DataReaderPeriodicReport& v1, const  ::OpenDDS::DCPS::DataReaderPeriodicReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.dr_id.guidPrefix[0] < v2.dr_id.guidPrefix[0]) return true;
    if (v2.dr_id.guidPrefix[0] < v1.dr_id.guidPrefix[0]) return false;
    if (v1.dr_id.guidPrefix[1] < v2.dr_id.guidPrefix[1]) return true;
    if (v2.dr_id.guidPrefix[1] < v1.dr_id.guidPrefix[1]) return false;
    if (v1.dr_id.guidPrefix[2] < v2.dr_id.guidPrefix[2]) return true;
    if (v2.dr_id.guidPrefix[2] < v1.dr_id.guidPrefix[2]) return false;
    if (v1.dr_id.guidPrefix[3] < v2.dr_id.guidPrefix[3]) return true;
    if (v2.dr_id.guidPrefix[3] < v1.dr_id.guidPrefix[3]) return false;
    if (v1.dr_id.guidPrefix[4] < v2.dr_id.guidPrefix[4]) return true;
    if (v2.dr_id.guidPrefix[4] < v1.dr_id.guidPrefix[4]) return false;
    if (v1.dr_id.guidPrefix[5] < v2.dr_id.guidPrefix[5]) return true;
    if (v2.dr_id.guidPrefix[5] < v1.dr_id.guidPrefix[5]) return false;
    if (v1.dr_id.guidPrefix[6] < v2.dr_id.guidPrefix[6]) return true;
    if (v2.dr_id.guidPrefix[6] < v1.dr_id.guidPrefix[6]) return false;
    if (v1.dr_id.guidPrefix[7] < v2.dr_id.guidPrefix[7]) return true;
    if (v2.dr_id.guidPrefix[7] < v1.dr_id.guidPrefix[7]) return false;
    if (v1.dr_id.guidPrefix[8] < v2.dr_id.guidPrefix[8]) return true;
    if (v2.dr_id.guidPrefix[8] < v1.dr_id.guidPrefix[8]) return false;
    if (v1.dr_id.guidPrefix[9] < v2.dr_id.guidPrefix[9]) return true;
    if (v2.dr_id.guidPrefix[9] < v1.dr_id.guidPrefix[9]) return false;
    if (v1.dr_id.guidPrefix[10] < v2.dr_id.guidPrefix[10]) return true;
    if (v2.dr_id.guidPrefix[10] < v1.dr_id.guidPrefix[10]) return false;
    if (v1.dr_id.guidPrefix[11] < v2.dr_id.guidPrefix[11]) return true;
    if (v2.dr_id.guidPrefix[11] < v1.dr_id.guidPrefix[11]) return false;
    if (v1.dr_id.entityId.entityKey[0] < v2.dr_id.entityId.entityKey[0]) return true;
    if (v2.dr_id.entityId.entityKey[0] < v1.dr_id.entityId.entityKey[0]) return false;
    if (v1.dr_id.entityId.entityKey[1] < v2.dr_id.entityId.entityKey[1]) return true;
    if (v2.dr_id.entityId.entityKey[1] < v1.dr_id.entityId.entityKey[1]) return false;
    if (v1.dr_id.entityId.entityKey[2] < v2.dr_id.entityId.entityKey[2]) return true;
    if (v2.dr_id.entityId.entityKey[2] < v1.dr_id.entityId.entityKey[2]) return false;
    if (v1.dr_id.entityId.entityKind < v2.dr_id.entityId.entityKind) return true;
    if (v2.dr_id.entityId.entityKind < v1.dr_id.entityId.entityKind) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class DataReaderPeriodicReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::DataReaderPeriodicReport> {
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReport MessageType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::DataReaderPeriodicReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::DataReaderPeriodicReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_DataReaderPeriodicReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::DataReaderPeriodicReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export DataReaderPeriodicReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<DataReaderPeriodicReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<DataReaderPeriodicReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<DataReaderPeriodicReport>
{
public:
  typedef DataReaderPeriodicReportTypeSupport TypeSupportType;
  typedef DataReaderPeriodicReportTypeSupport::_var_type _var_type;
  typedef DataReaderPeriodicReportTypeSupport::_ptr_type _ptr_type;

  DataReaderPeriodicReportTypeSupportImpl() {}
  virtual ~DataReaderPeriodicReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static DataReaderPeriodicReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::DataReaderPeriodicReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::DataReaderPeriodicReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderPeriodicReport */


/* Begin STRUCT: TransportReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_TransportReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_TransportReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_TransportReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::TransportReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::TransportReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const ::OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::TransportReport& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::OpenDDS::DCPS::TransportReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::OpenDDS::DCPS::TransportReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::OpenDDS::DCPS::TransportReport>& stru);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::OpenDDS::DCPS::TransportReport>& stru);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::OpenDDS::DCPS::TransportReport>& stru);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, const KeyOnly< ::OpenDDS::DCPS::TransportReport>& stru);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::TransportReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::TransportReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::TransportReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_monitor_Export TransportReport_OpenDDS_KeyLessThan {
  bool operator()(const  ::OpenDDS::DCPS::TransportReport& v1, const  ::OpenDDS::DCPS::TransportReport& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.host < v2.host) return true;
    if (v2.host < v1.host) return false;
    if (v1.pid < v2.pid) return true;
    if (v2.pid < v1.pid) return false;
    if (v1.transport_id < v2.transport_id) return true;
    if (v2.transport_id < v1.transport_id) return false;
    return false;
  }
};
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class TransportReportTypeSupportImpl;
}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::OpenDDS::DCPS::TransportReport> {
  typedef  ::OpenDDS::DCPS::TransportReport MessageType;
  typedef  ::OpenDDS::DCPS::TransportReportSeq MessageSequenceType;
  typedef  ::OpenDDS::DCPS::TransportReportTypeSupport TypeSupportType;
  typedef  ::OpenDDS::DCPS::TransportReportTypeSupportImpl TypeSupportImplType;
  typedef  ::OpenDDS::DCPS::TransportReportDataWriter DataWriterType;
  typedef  ::OpenDDS::DCPS::TransportReportDataReader DataReaderType;
  typedef  ::OpenDDS::DCPS::TransportReport_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::OpenDDS::DCPS::TransportReport> KeyOnlyType;
  typedef OpenDDS::DCPS::OpenDDS_DCPS_TransportReport_xtag XtagType;

  static const char* type_name() { return "OpenDDS::DCPS::TransportReport"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 3; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
class OpenDDS_monitor_Export TransportReportTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TransportReportTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<TransportReport>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<TransportReport>
{
public:
  typedef TransportReportTypeSupport TypeSupportType;
  typedef TransportReportTypeSupport::_var_type _var_type;
  typedef TransportReportTypeSupport::_ptr_type _ptr_type;

  TransportReportTypeSupportImpl() {}
  virtual ~TransportReportTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static TransportReportTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::TransportReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::TransportReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportReport */


/* Begin ENUM: ReportType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_ReportType_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_ReportType_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_ReportType_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::ReportType& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::ReportType& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::ReportType& enumval);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::ReportType& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export extern const char* gen_OpenDDS_DCPS_ReportType_names[];
OpenDDS_monitor_Export extern const size_t gen_OpenDDS_DCPS_ReportType_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ReportType */


/* Begin UNION: GenericReport */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct OpenDDS_DCPS_GenericReport_xtag {};
template<> OpenDDS_monitor_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<OpenDDS_DCPS_GenericReport_xtag>();

template<> OpenDDS_monitor_Export
const XTypes::TypeMap& getMinimalTypeMap<OpenDDS_DCPS_GenericReport_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::OpenDDS::DCPS::GenericReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_monitor_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::OpenDDS::DCPS::GenericReport& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_monitor_Export
void set_default( ::OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, const  ::OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm,  ::OpenDDS::DCPS::GenericReport& uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, NestedKeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, NestedKeyOnly< ::OpenDDS::DCPS::GenericReport> uni);

OpenDDS_monitor_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni);

OpenDDS_monitor_Export
bool operator<<(Serializer& strm, KeyOnly<const  ::OpenDDS::DCPS::GenericReport> uni);

OpenDDS_monitor_Export
bool operator>>(Serializer& strm, KeyOnly< ::OpenDDS::DCPS::GenericReport> uni);

template <>
struct MarshalTraits< ::OpenDDS::DCPS::GenericReport> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::OpenDDS::DCPS::GenericReport&) { return false; }
  static bool from_message_block( ::OpenDDS::DCPS::GenericReport&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_monitor_Export
const MetaStruct& getMetaStruct< ::OpenDDS::DCPS::GenericReport>();
OpenDDS_monitor_Export
bool gen_skip_over(Serializer& ser,  ::OpenDDS::DCPS::GenericReport*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: GenericReport */


/* Begin INTERFACE: ProcessMonitor */


/* End INTERFACE: ProcessMonitor */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_MONITORTYPESUPPORTIMPL_H_US2NMR */
