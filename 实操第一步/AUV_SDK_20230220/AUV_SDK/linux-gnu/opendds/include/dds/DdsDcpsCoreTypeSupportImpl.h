/* -*- C++ -*- */
/* Generated by /mnt/d/Work/OpenDDS-SDK-Build/OpenDDS-master/bin/opendds_idl version 3.23.0-dev (ACE version 6.2a_p25) running on input file DdsDcpsCore.idl */
#ifndef OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_V5YKGM
#define OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_V5YKGM

#include <dds/Version.h>
#if !OPENDDS_VERSION_EXACTLY(3, 23, 0)
#  error "This file should be regenerated with opendds_idl"
#endif
#include <dds/DCPS/Definitions.h>

#include <dds/DdsDcpsC.h>

#include "DdsDcpsCoreC.h"
#include "DdsDcpsCoreTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/ValueDispatcher.h"
#include "dds/DCPS/ValueReader.h"
#include "dds/DCPS/ValueWriter.h"
#include "dds/DCPS/XTypes/TypeObject.h"
#include "tao/LongSeqC.h"
#include "tao/ShortSeqC.h"
#include "tao/StringSeqC.h"
#include "dds/DCPS/dcps_export.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_StringSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_StringSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_StringSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::StringSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::StringSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::StringSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::StringSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_InstanceHandle_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceHandle_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceHandle_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: InstanceHandleSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_InstanceHandleSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceHandleSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceHandleSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::InstanceHandleSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::InstanceHandleSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::InstanceHandleSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::InstanceHandleSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_QosPolicyId_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyId_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyId_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_QosPolicyCount_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyCount_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyCount_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::QosPolicyCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::QosPolicyCount& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::QosPolicyCount& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::QosPolicyCount>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::QosPolicyCount>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::QosPolicyCount>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::QosPolicyCount>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::QosPolicyCount*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_QosPolicyCountSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_QosPolicyCountSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_QosPolicyCountSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::QosPolicyCountSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::QosPolicyCountSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::QosPolicyCountSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::QosPolicyCountSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_OctetSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OctetSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_OctetSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OctetSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::OctetSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::OctetSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::OctetSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_Duration_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Duration_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_Duration_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Duration_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Duration_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::Duration_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::Duration_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::Duration_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::Duration_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::Duration_t>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::Duration_t>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::Duration_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::Duration_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::Duration_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_Property_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Property_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_Property_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Property_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Property_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::Property_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::Property_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::Property_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::Property_t& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::Property_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::Property_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PropertySeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PropertySeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PropertySeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PropertySeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::PropertySeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PropertySeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PropertySeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_BinaryProperty_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BinaryProperty_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_BinaryProperty_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::BinaryProperty_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::BinaryProperty_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::BinaryProperty_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::BinaryProperty_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::BinaryProperty_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::BinaryProperty_t& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::BinaryProperty_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::BinaryProperty_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_BinaryPropertySeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BinaryPropertySeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_BinaryPropertySeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::BinaryPropertySeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::BinaryPropertySeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::BinaryPropertySeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::BinaryPropertySeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PropertyQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PropertyQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PropertyQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PropertyQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PropertyQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::PropertyQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::PropertyQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::PropertyQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PropertyQosPolicy& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::PropertyQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PropertyQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_UserDataQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_UserDataQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_UserDataQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::UserDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::UserDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::UserDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::UserDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::UserDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::UserDataQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::UserDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::UserDataQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_GroupDataQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_GroupDataQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_GroupDataQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::GroupDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::GroupDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::GroupDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::GroupDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::GroupDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::GroupDataQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::GroupDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::GroupDataQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TopicDataQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicDataQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicDataQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicDataQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TopicDataQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TopicDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TopicDataQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicDataQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TopicDataQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TopicDataQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PartitionQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PartitionQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PartitionQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PartitionQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PartitionQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PartitionQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::PartitionQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::PartitionQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PartitionQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::PartitionQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PartitionQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_HistoryQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_HistoryQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_HistoryQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::HistoryQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::HistoryQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::HistoryQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::HistoryQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_HistoryQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_HistoryQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DurabilityQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::DurabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DurabilityQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_DurabilityQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_DurabilityQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DurabilityQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DurabilityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DurabilityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DurabilityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DurabilityQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DurabilityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DurabilityQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DurabilityServiceQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DurabilityServiceQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DurabilityServiceQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DurabilityServiceQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DurabilityServiceQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DurabilityServiceQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DurabilityServiceQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DurabilityServiceQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DurabilityServiceQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DurabilityServiceQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DurabilityServiceQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DeadlineQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DeadlineQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DeadlineQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DeadlineQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DeadlineQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DeadlineQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DeadlineQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DeadlineQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DeadlineQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DeadlineQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DeadlineQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_LatencyBudgetQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LatencyBudgetQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_LatencyBudgetQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LatencyBudgetQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LatencyBudgetQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::LatencyBudgetQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::LatencyBudgetQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::LatencyBudgetQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LatencyBudgetQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::LatencyBudgetQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::LatencyBudgetQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_LivelinessQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::LivelinessQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::LivelinessQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_LivelinessQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_LivelinessQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_LivelinessQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LivelinessQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_LivelinessQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LivelinessQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LivelinessQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::LivelinessQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::LivelinessQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::LivelinessQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LivelinessQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::LivelinessQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::LivelinessQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ReliabilityQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReliabilityQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ReliabilityQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReliabilityQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReliabilityQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::ReliabilityQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::ReliabilityQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_ReliabilityQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_ReliabilityQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ReliabilityQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReliabilityQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ReliabilityQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReliabilityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReliabilityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::ReliabilityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::ReliabilityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::ReliabilityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ReliabilityQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::ReliabilityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::ReliabilityQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DestinationOrderQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DestinationOrderQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DestinationOrderQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DestinationOrderQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DestinationOrderQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::DestinationOrderQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DestinationOrderQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_DestinationOrderQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_DestinationOrderQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DestinationOrderQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DestinationOrderQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DestinationOrderQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DestinationOrderQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DestinationOrderQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DestinationOrderQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DestinationOrderQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DestinationOrderQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DestinationOrderQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DestinationOrderQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DestinationOrderQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_HistoryQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_HistoryQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_HistoryQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::HistoryQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::HistoryQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::HistoryQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::HistoryQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::HistoryQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::HistoryQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::HistoryQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::HistoryQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ResourceLimitsQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ResourceLimitsQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ResourceLimitsQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ResourceLimitsQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ResourceLimitsQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::ResourceLimitsQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::ResourceLimitsQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::ResourceLimitsQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ResourceLimitsQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::ResourceLimitsQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::ResourceLimitsQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TransportPriorityQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TransportPriorityQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TransportPriorityQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TransportPriorityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TransportPriorityQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TransportPriorityQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TransportPriorityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TransportPriorityQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TransportPriorityQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TransportPriorityQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TransportPriorityQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_LifespanQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_LifespanQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_LifespanQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::LifespanQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::LifespanQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::LifespanQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::LifespanQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::LifespanQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::LifespanQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::LifespanQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::LifespanQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_OwnershipQosPolicyKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipQosPolicyKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipQosPolicyKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipQosPolicyKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::OwnershipQosPolicyKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::OwnershipQosPolicyKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_OwnershipQosPolicyKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_OwnershipQosPolicyKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_OwnershipQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::OwnershipQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::OwnershipQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::OwnershipQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OwnershipQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::OwnershipQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::OwnershipQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_OwnershipStrengthQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OwnershipStrengthQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_OwnershipStrengthQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::OwnershipStrengthQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::OwnershipStrengthQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::OwnershipStrengthQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::OwnershipStrengthQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::OwnershipStrengthQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::OwnershipStrengthQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::OwnershipStrengthQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::OwnershipStrengthQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PresentationQosPolicyAccessScopeKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PresentationQosPolicyAccessScopeKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PresentationQosPolicyAccessScopeKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PresentationQosPolicyAccessScopeKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PresentationQosPolicyAccessScopeKind& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::PresentationQosPolicyAccessScopeKind& enumval);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PresentationQosPolicyAccessScopeKind& enumval);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export extern const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[];
OpenDDS_Dcps_Export extern const size_t gen_DDS_PresentationQosPolicyAccessScopeKind_names_size;
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PresentationQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PresentationQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PresentationQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PresentationQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PresentationQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PresentationQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::PresentationQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::PresentationQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PresentationQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::PresentationQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PresentationQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TimeBasedFilterQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TimeBasedFilterQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TimeBasedFilterQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TimeBasedFilterQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TimeBasedFilterQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TimeBasedFilterQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TimeBasedFilterQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TimeBasedFilterQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TimeBasedFilterQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TimeBasedFilterQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TimeBasedFilterQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin TYPEDEF: DataRepresentationId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DataRepresentationId_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationId_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationId_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: DataRepresentationId_t */


/* Begin CONST: XCDR_DATA_REPRESENTATION */


/* End CONST: XCDR_DATA_REPRESENTATION */


/* Begin CONST: XML_DATA_REPRESENTATION */


/* End CONST: XML_DATA_REPRESENTATION */


/* Begin CONST: XCDR2_DATA_REPRESENTATION */


/* End CONST: XCDR2_DATA_REPRESENTATION */


/* Begin TYPEDEF: DataRepresentationIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DataRepresentationIdSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationIdSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationIdSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::DataRepresentationIdSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::DataRepresentationIdSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DataRepresentationIdSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DataRepresentationIdSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: DataRepresentationIdSeq */


/* Begin STRUCT: DataRepresentationQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DataRepresentationQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataRepresentationQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DataRepresentationQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataRepresentationQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataRepresentationQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DataRepresentationQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DataRepresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DataRepresentationQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DataRepresentationQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DataRepresentationQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DataRepresentationQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataRepresentationQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DataRepresentationQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DataRepresentationQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataRepresentationQosPolicy */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* End CONST: DATA_REPRESENTATION_QOS_POLICY_NAME */


/* Begin TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TypeConsistencyEnforcementQosPolicyKind_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TypeConsistencyEnforcementQosPolicyKind_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TypeConsistencyEnforcementQosPolicyKind_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: TypeConsistencyEnforcementQosPolicyKind_t */


/* Begin CONST: DISALLOW_TYPE_COERCION */


/* End CONST: DISALLOW_TYPE_COERCION */


/* Begin CONST: ALLOW_TYPE_COERCION */


/* End CONST: ALLOW_TYPE_COERCION */


/* Begin STRUCT: TypeConsistencyEnforcementQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TypeConsistencyEnforcementQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TypeConsistencyEnforcementQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TypeConsistencyEnforcementQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TypeConsistencyEnforcementQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TypeConsistencyEnforcementQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TypeConsistencyEnforcementQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TypeConsistencyEnforcementQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TypeConsistencyEnforcementQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TypeConsistencyEnforcementQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TypeConsistencyEnforcementQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TypeConsistencyEnforcementQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TypeConsistencyEnforcementQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TypeConsistencyEnforcementQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TypeConsistencyEnforcementQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TypeConsistencyEnforcementQosPolicy */


/* Begin STRUCT: TopicQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TopicQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TopicQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TopicQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TopicQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TopicQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TopicQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TopicQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TopicQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TopicQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_WriterDataLifecycleQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_WriterDataLifecycleQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_WriterDataLifecycleQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::WriterDataLifecycleQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::WriterDataLifecycleQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::WriterDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::WriterDataLifecycleQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::WriterDataLifecycleQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::WriterDataLifecycleQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::WriterDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::WriterDataLifecycleQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DataWriterQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataWriterQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DataWriterQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataWriterQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataWriterQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DataWriterQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DataWriterQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DataWriterQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataWriterQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DataWriterQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DataWriterQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_EntityFactoryQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_EntityFactoryQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_EntityFactoryQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::EntityFactoryQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::EntityFactoryQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::EntityFactoryQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::EntityFactoryQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::EntityFactoryQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::EntityFactoryQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::EntityFactoryQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::EntityFactoryQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PublisherQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PublisherQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PublisherQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PublisherQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PublisherQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PublisherQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::PublisherQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::PublisherQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PublisherQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::PublisherQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PublisherQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ReaderDataLifecycleQosPolicy_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ReaderDataLifecycleQosPolicy_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ReaderDataLifecycleQosPolicy_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ReaderDataLifecycleQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ReaderDataLifecycleQosPolicy& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::ReaderDataLifecycleQosPolicy& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::ReaderDataLifecycleQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::ReaderDataLifecycleQosPolicy>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ReaderDataLifecycleQosPolicy>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::ReaderDataLifecycleQosPolicy>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::ReaderDataLifecycleQosPolicy*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DataReaderQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DataReaderQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DataReaderQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DataReaderQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DataReaderQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DataReaderQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DataReaderQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DataReaderQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DataReaderQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DataReaderQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DataReaderQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SubscriberQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SubscriberQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SubscriberQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SubscriberQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SubscriberQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::SubscriberQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::SubscriberQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::SubscriberQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SubscriberQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::SubscriberQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::SubscriberQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DomainParticipantFactoryQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DomainParticipantFactoryQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DomainParticipantFactoryQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DomainParticipantFactoryQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DomainParticipantFactoryQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DomainParticipantFactoryQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DomainParticipantFactoryQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DomainParticipantFactoryQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DomainParticipantFactoryQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DomainParticipantFactoryQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DomainParticipantFactoryQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_DomainParticipantQos_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_DomainParticipantQos_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_DomainParticipantQos_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::DomainParticipantQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::DomainParticipantQos& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::DomainParticipantQos& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::DomainParticipantQos>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::DomainParticipantQos>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::DomainParticipantQos>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::DomainParticipantQos>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::DomainParticipantQos*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DomainParticipantQos */


/* Begin TYPEDEF: OctetArray16 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_OctetArray16_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_OctetArray16_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_OctetArray16_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::OctetArray16_forany& arr);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::OctetArray16_forany& arr);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::OctetArray16_forany& arr);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::OctetArray16_forany& arr);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::OctetArray16_forany*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: BuiltinTopicKey_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_BuiltinTopicKey_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_BuiltinTopicKey_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_BuiltinTopicKey_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::BuiltinTopicKey_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::BuiltinTopicKey_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::BuiltinTopicKey_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::BuiltinTopicKey_t>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::BuiltinTopicKey_t>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::BuiltinTopicKey_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::BuiltinTopicKey_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::BuiltinTopicKey_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ParticipantBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ParticipantBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ParticipantBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::ParticipantBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::ParticipantBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::ParticipantBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::ParticipantBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::ParticipantBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::ParticipantBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::DDS::ParticipantBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::DDS::ParticipantBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::DDS::ParticipantBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::DDS::ParticipantBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::DDS::ParticipantBuiltinTopicData&) { return false; }
  static bool from_message_block( ::DDS::ParticipantBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export ParticipantBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::DDS::ParticipantBuiltinTopicData& v1, const  ::DDS::ParticipantBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    if (v1.key.value[3] < v2.key.value[3]) return true;
    if (v2.key.value[3] < v1.key.value[3]) return false;
    if (v1.key.value[4] < v2.key.value[4]) return true;
    if (v2.key.value[4] < v1.key.value[4]) return false;
    if (v1.key.value[5] < v2.key.value[5]) return true;
    if (v2.key.value[5] < v1.key.value[5]) return false;
    if (v1.key.value[6] < v2.key.value[6]) return true;
    if (v2.key.value[6] < v1.key.value[6]) return false;
    if (v1.key.value[7] < v2.key.value[7]) return true;
    if (v2.key.value[7] < v1.key.value[7]) return false;
    if (v1.key.value[8] < v2.key.value[8]) return true;
    if (v2.key.value[8] < v1.key.value[8]) return false;
    if (v1.key.value[9] < v2.key.value[9]) return true;
    if (v2.key.value[9] < v1.key.value[9]) return false;
    if (v1.key.value[10] < v2.key.value[10]) return true;
    if (v2.key.value[10] < v1.key.value[10]) return false;
    if (v1.key.value[11] < v2.key.value[11]) return true;
    if (v2.key.value[11] < v1.key.value[11]) return false;
    if (v1.key.value[12] < v2.key.value[12]) return true;
    if (v2.key.value[12] < v1.key.value[12]) return false;
    if (v1.key.value[13] < v2.key.value[13]) return true;
    if (v2.key.value[13] < v1.key.value[13]) return false;
    if (v1.key.value[14] < v2.key.value[14]) return true;
    if (v2.key.value[14] < v1.key.value[14]) return false;
    if (v1.key.value[15] < v2.key.value[15]) return true;
    if (v2.key.value[15] < v1.key.value[15]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class ParticipantBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::DDS::ParticipantBuiltinTopicData> {
  typedef  ::DDS::ParticipantBuiltinTopicData MessageType;
  typedef  ::DDS::ParticipantBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::DDS::ParticipantBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::DDS::ParticipantBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::DDS::ParticipantBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::DDS::ParticipantBuiltinTopicDataDataReader DataReaderType;
  typedef  ::DDS::ParticipantBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::DDS::ParticipantBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::DDS_ParticipantBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "DDS::ParticipantBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export ParticipantBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<ParticipantBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<ParticipantBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<ParticipantBuiltinTopicData>
{
public:
  typedef ParticipantBuiltinTopicDataTypeSupport TypeSupportType;
  typedef ParticipantBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef ParticipantBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  ParticipantBuiltinTopicDataTypeSupportImpl() {}
  virtual ~ParticipantBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static ParticipantBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::ParticipantBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::ParticipantBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_PublicationBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_PublicationBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_PublicationBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::PublicationBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::PublicationBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::PublicationBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::PublicationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::PublicationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::PublicationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::DDS::PublicationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::DDS::PublicationBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::DDS::PublicationBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::DDS::PublicationBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::DDS::PublicationBuiltinTopicData&) { return false; }
  static bool from_message_block( ::DDS::PublicationBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export PublicationBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::DDS::PublicationBuiltinTopicData& v1, const  ::DDS::PublicationBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    if (v1.key.value[3] < v2.key.value[3]) return true;
    if (v2.key.value[3] < v1.key.value[3]) return false;
    if (v1.key.value[4] < v2.key.value[4]) return true;
    if (v2.key.value[4] < v1.key.value[4]) return false;
    if (v1.key.value[5] < v2.key.value[5]) return true;
    if (v2.key.value[5] < v1.key.value[5]) return false;
    if (v1.key.value[6] < v2.key.value[6]) return true;
    if (v2.key.value[6] < v1.key.value[6]) return false;
    if (v1.key.value[7] < v2.key.value[7]) return true;
    if (v2.key.value[7] < v1.key.value[7]) return false;
    if (v1.key.value[8] < v2.key.value[8]) return true;
    if (v2.key.value[8] < v1.key.value[8]) return false;
    if (v1.key.value[9] < v2.key.value[9]) return true;
    if (v2.key.value[9] < v1.key.value[9]) return false;
    if (v1.key.value[10] < v2.key.value[10]) return true;
    if (v2.key.value[10] < v1.key.value[10]) return false;
    if (v1.key.value[11] < v2.key.value[11]) return true;
    if (v2.key.value[11] < v1.key.value[11]) return false;
    if (v1.key.value[12] < v2.key.value[12]) return true;
    if (v2.key.value[12] < v1.key.value[12]) return false;
    if (v1.key.value[13] < v2.key.value[13]) return true;
    if (v2.key.value[13] < v1.key.value[13]) return false;
    if (v1.key.value[14] < v2.key.value[14]) return true;
    if (v2.key.value[14] < v1.key.value[14]) return false;
    if (v1.key.value[15] < v2.key.value[15]) return true;
    if (v2.key.value[15] < v1.key.value[15]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class PublicationBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::DDS::PublicationBuiltinTopicData> {
  typedef  ::DDS::PublicationBuiltinTopicData MessageType;
  typedef  ::DDS::PublicationBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::DDS::PublicationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::DDS::PublicationBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::DDS::PublicationBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::DDS::PublicationBuiltinTopicDataDataReader DataReaderType;
  typedef  ::DDS::PublicationBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::DDS::PublicationBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::DDS_PublicationBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "DDS::PublicationBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export PublicationBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<PublicationBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<PublicationBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<PublicationBuiltinTopicData>
{
public:
  typedef PublicationBuiltinTopicDataTypeSupport TypeSupportType;
  typedef PublicationBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef PublicationBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  PublicationBuiltinTopicDataTypeSupportImpl() {}
  virtual ~PublicationBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static PublicationBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::PublicationBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::PublicationBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SubscriptionBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SubscriptionBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SubscriptionBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SubscriptionBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SubscriptionBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::SubscriptionBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::SubscriptionBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::SubscriptionBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SubscriptionBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::DDS::SubscriptionBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::DDS::SubscriptionBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::DDS::SubscriptionBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::DDS::SubscriptionBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::DDS::SubscriptionBuiltinTopicData&) { return false; }
  static bool from_message_block( ::DDS::SubscriptionBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export SubscriptionBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::DDS::SubscriptionBuiltinTopicData& v1, const  ::DDS::SubscriptionBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    if (v1.key.value[3] < v2.key.value[3]) return true;
    if (v2.key.value[3] < v1.key.value[3]) return false;
    if (v1.key.value[4] < v2.key.value[4]) return true;
    if (v2.key.value[4] < v1.key.value[4]) return false;
    if (v1.key.value[5] < v2.key.value[5]) return true;
    if (v2.key.value[5] < v1.key.value[5]) return false;
    if (v1.key.value[6] < v2.key.value[6]) return true;
    if (v2.key.value[6] < v1.key.value[6]) return false;
    if (v1.key.value[7] < v2.key.value[7]) return true;
    if (v2.key.value[7] < v1.key.value[7]) return false;
    if (v1.key.value[8] < v2.key.value[8]) return true;
    if (v2.key.value[8] < v1.key.value[8]) return false;
    if (v1.key.value[9] < v2.key.value[9]) return true;
    if (v2.key.value[9] < v1.key.value[9]) return false;
    if (v1.key.value[10] < v2.key.value[10]) return true;
    if (v2.key.value[10] < v1.key.value[10]) return false;
    if (v1.key.value[11] < v2.key.value[11]) return true;
    if (v2.key.value[11] < v1.key.value[11]) return false;
    if (v1.key.value[12] < v2.key.value[12]) return true;
    if (v2.key.value[12] < v1.key.value[12]) return false;
    if (v1.key.value[13] < v2.key.value[13]) return true;
    if (v2.key.value[13] < v1.key.value[13]) return false;
    if (v1.key.value[14] < v2.key.value[14]) return true;
    if (v2.key.value[14] < v1.key.value[14]) return false;
    if (v1.key.value[15] < v2.key.value[15]) return true;
    if (v2.key.value[15] < v1.key.value[15]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class SubscriptionBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::DDS::SubscriptionBuiltinTopicData> {
  typedef  ::DDS::SubscriptionBuiltinTopicData MessageType;
  typedef  ::DDS::SubscriptionBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::DDS::SubscriptionBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::DDS::SubscriptionBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::DDS::SubscriptionBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::DDS::SubscriptionBuiltinTopicDataDataReader DataReaderType;
  typedef  ::DDS::SubscriptionBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::DDS::SubscriptionBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::DDS_SubscriptionBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "DDS::SubscriptionBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export SubscriptionBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<SubscriptionBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<SubscriptionBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<SubscriptionBuiltinTopicData>
{
public:
  typedef SubscriptionBuiltinTopicDataTypeSupport TypeSupportType;
  typedef SubscriptionBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef SubscriptionBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  SubscriptionBuiltinTopicDataTypeSupportImpl() {}
  virtual ~SubscriptionBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static SubscriptionBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::SubscriptionBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::SubscriptionBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_TopicBuiltinTopicData_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_TopicBuiltinTopicData_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_TopicBuiltinTopicData_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::TopicBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::TopicBuiltinTopicData& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::TopicBuiltinTopicData& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::TopicBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::TopicBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::TopicBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const ::DDS::TopicBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const KeyOnly<const ::DDS::TopicBuiltinTopicData>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const KeyOnly< ::DDS::TopicBuiltinTopicData>& stru);

template <>
struct MarshalTraits< ::DDS::TopicBuiltinTopicData> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(4);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
    seq[3] = OpenDDS::DCPS::UNALIGNED_CDR_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(16);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const  ::DDS::TopicBuiltinTopicData&) { return false; }
  static bool from_message_block( ::DDS::TopicBuiltinTopicData&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
/// This structure supports use of std::map with one or more keys.
struct OpenDDS_Dcps_Export TopicBuiltinTopicData_OpenDDS_KeyLessThan {
  bool operator()(const  ::DDS::TopicBuiltinTopicData& v1, const  ::DDS::TopicBuiltinTopicData& v2) const
  {
    using ::operator<; // TAO::String_Manager's operator< is in global NS
    if (v1.key.value[0] < v2.key.value[0]) return true;
    if (v2.key.value[0] < v1.key.value[0]) return false;
    if (v1.key.value[1] < v2.key.value[1]) return true;
    if (v2.key.value[1] < v1.key.value[1]) return false;
    if (v1.key.value[2] < v2.key.value[2]) return true;
    if (v2.key.value[2] < v1.key.value[2]) return false;
    if (v1.key.value[3] < v2.key.value[3]) return true;
    if (v2.key.value[3] < v1.key.value[3]) return false;
    if (v1.key.value[4] < v2.key.value[4]) return true;
    if (v2.key.value[4] < v1.key.value[4]) return false;
    if (v1.key.value[5] < v2.key.value[5]) return true;
    if (v2.key.value[5] < v1.key.value[5]) return false;
    if (v1.key.value[6] < v2.key.value[6]) return true;
    if (v2.key.value[6] < v1.key.value[6]) return false;
    if (v1.key.value[7] < v2.key.value[7]) return true;
    if (v2.key.value[7] < v1.key.value[7]) return false;
    if (v1.key.value[8] < v2.key.value[8]) return true;
    if (v2.key.value[8] < v1.key.value[8]) return false;
    if (v1.key.value[9] < v2.key.value[9]) return true;
    if (v2.key.value[9] < v1.key.value[9]) return false;
    if (v1.key.value[10] < v2.key.value[10]) return true;
    if (v2.key.value[10] < v1.key.value[10]) return false;
    if (v1.key.value[11] < v2.key.value[11]) return true;
    if (v2.key.value[11] < v1.key.value[11]) return false;
    if (v1.key.value[12] < v2.key.value[12]) return true;
    if (v2.key.value[12] < v1.key.value[12]) return false;
    if (v1.key.value[13] < v2.key.value[13]) return true;
    if (v2.key.value[13] < v1.key.value[13]) return false;
    if (v1.key.value[14] < v2.key.value[14]) return true;
    if (v2.key.value[14] < v1.key.value[14]) return false;
    if (v1.key.value[15] < v2.key.value[15]) return true;
    if (v2.key.value[15] < v1.key.value[15]) return false;
    return false;
  }
};
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class TopicBuiltinTopicDataTypeSupportImpl;
}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits< ::DDS::TopicBuiltinTopicData> {
  typedef  ::DDS::TopicBuiltinTopicData MessageType;
  typedef  ::DDS::TopicBuiltinTopicDataSeq MessageSequenceType;
  typedef  ::DDS::TopicBuiltinTopicDataTypeSupport TypeSupportType;
  typedef  ::DDS::TopicBuiltinTopicDataTypeSupportImpl TypeSupportImplType;
  typedef  ::DDS::TopicBuiltinTopicDataDataWriter DataWriterType;
  typedef  ::DDS::TopicBuiltinTopicDataDataReader DataReaderType;
  typedef  ::DDS::TopicBuiltinTopicData_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const  ::DDS::TopicBuiltinTopicData> KeyOnlyType;
  typedef OpenDDS::DCPS::DDS_TopicBuiltinTopicData_xtag XtagType;

  static const char* type_name() { return "DDS::TopicBuiltinTopicData"; }
  static bool gen_has_key() { return true; }
  static size_t key_count() { return 16; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace DDS {
class OpenDDS_Dcps_Export TopicBuiltinTopicDataTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<TopicBuiltinTopicDataTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl_T<TopicBuiltinTopicData>
  , public virtual OpenDDS::DCPS::ValueDispatcher_T<TopicBuiltinTopicData>
{
public:
  typedef TopicBuiltinTopicDataTypeSupport TypeSupportType;
  typedef TopicBuiltinTopicDataTypeSupport::_var_type _var_type;
  typedef TopicBuiltinTopicDataTypeSupport::_ptr_type _ptr_type;

  TopicBuiltinTopicDataTypeSupportImpl() {}
  virtual ~TopicBuiltinTopicDataTypeSupportImpl() {}

  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataWriter_ptr create_datawriter();
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual OPENDDS_VERSIONED_NAMESPACE_NAME::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual const OpenDDS::XTypes::TypeIdentifier& getCompleteTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getCompleteTypeMap() const;

  static TopicBuiltinTopicDataTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};

}
OPENDDS_END_VERSIONED_NAMESPACE_DECL
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::TopicBuiltinTopicData>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::TopicBuiltinTopicData*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SampleStateKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleStateKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleStateKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SampleStateMask_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleStateMask_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleStateMask_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ViewStateKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ViewStateKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ViewStateKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_ViewStateMask_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_ViewStateMask_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_ViewStateMask_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_InstanceStateKind_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceStateKind_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceStateKind_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_InstanceStateMask_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_InstanceStateMask_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_InstanceStateMask_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_Time_t_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_Time_t_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_Time_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::Time_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::Time_t& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::Time_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::Time_t& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::Time_t& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::Time_t& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::Time_t>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::Time_t>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::Time_t>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::Time_t>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::Time_t*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SampleInfo_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleInfo_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleInfo_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool vread(OpenDDS::DCPS::ValueReader& value_reader,  ::DDS::SampleInfo& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const  ::DDS::SampleInfo& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<> OpenDDS_Dcps_Export
void set_default( ::DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const ::DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const ::DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::SampleInfo& stru);

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const ::DDS::SampleInfo>& stru);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const NestedKeyOnly<const ::DDS::SampleInfo>& stru);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm, const NestedKeyOnly< ::DDS::SampleInfo>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
OpenDDS_Dcps_Export
const MetaStruct& getMetaStruct< ::DDS::SampleInfo>();
OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::SampleInfo*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct DDS_SampleInfoSeq_xtag {};
template<> OpenDDS_Dcps_Export
const XTypes::TypeIdentifier& getMinimalTypeIdentifier<DDS_SampleInfoSeq_xtag>();

template<> OpenDDS_Dcps_Export
const XTypes::TypeMap& getMinimalTypeMap<DDS_SampleInfoSeq_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
void serialized_size(const Encoding& encoding, size_t& size, const  ::DDS::SampleInfoSeq& seq);

OpenDDS_Dcps_Export
bool operator<<(Serializer& strm, const  ::DDS::SampleInfoSeq& seq);

OpenDDS_Dcps_Export
bool operator>>(Serializer& strm,  ::DDS::SampleInfoSeq& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

OpenDDS_Dcps_Export
bool gen_skip_over(Serializer& ser,  ::DDS::SampleInfoSeq*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin CONST: UNALIGNED_CDR_DATA_REPRESENTATION */


/* End CONST: UNALIGNED_CDR_DATA_REPRESENTATION */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_DDSDCPSCORETYPESUPPORTIMPL_H_V5YKGM */
